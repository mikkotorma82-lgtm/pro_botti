
from __future__ import annotations
import time, pandas as pd, numpy as np, joblib
from loguru import logger
from history.history_utils import start_history_thread, DEFAULT_TARGET_DAYS
from utils.dates import to_period_seconds
from features.feature_engineering import build_features
from models.trainer import pick_model
from strategy.alpha import signals_from_proba
from risk.risk import target_position_notional
from utils.misc import bp_to_float

def run_live(cfg, data_fetch_fn, price_fn, broker):
    # --- HistoryUpdater: pid√§ data ajan tasalla (2y/4y/10y) ---
    symbols_all = cfg.live.symbols  # ota configista
    tfs_all = cfg.live.timeframes   # esim. ['15m','1h','4h']
    try:
        start_history_thread(symbols_all, tfs_all, DEFAULT_TARGET_DAYS, interval_sec=3600)
    except Exception as e:
        logger.warning(f"[HistoryUpdater] not started: {e}")

    tf = cfg.market.timeframe
    poll = int(cfg.poll_seconds.get(tf, max(10, to_period_seconds(tf)//30)))
    logger.info(f"Live start tf={tf} poll={poll}s symbols={cfg.market.symbols}")
    # load bundle per symbol if exists; else train-on-the-fly minimal model
    bundles = {}
    from pathlib import Path
    for sym in cfg.market.symbols:
        path = Path(cfg.general.model_dir)/f"{sym}_{tf}.joblib"
        if path.exists():
            bundles[sym] = joblib.load(path)
        else:
            logger.warning(f"No model bundle for {sym} at {path}; signals will be zero until trained.")
            bundles[sym] = None
    last_ts = {s: None for s in cfg.market.symbols}
    while True:
        for sym in cfg.market.symbols:
            try:
                df = data_fetch_fn(sym, tf)
                if df is None or len(df)<200: 
                    continue
                if bundles[sym] is None:
                    continue
                feats = build_features(df, cfg.features)
                feats = feats.loc[df.index]
                used_cols = bundles[sym]["features"]
                X = feats[used_cols].dropna()
                if X.empty: 
                    continue
                model = bundles[sym]["models"][-1]
                p = pd.Series(model.predict_proba(X)[:,1], index=X.index)
                sig = signals_from_proba(p)
                # simple mapping -> target notional using recent vol
                vol_ann = X["ret_1"].rolling(96).std().iloc[-1]*np.sqrt(96*365*24*60/int(to_period_seconds(tf)/60))
                acct = broker.get_account_summary()
                equity = float(acct.get("equity") or acct.get("balance") or acct.get("cash") or 0.0)
                tgt_notional = target_position_notional(equity, float(vol_ann or 0.0), cfg.execution.risk, cfg.execution.sizing, int(sig.iloc[-1]))
                # convert notional to qty
                px = float(df["close"].iloc[-1])
                qty = abs(tgt_notional/px)
                if qty <= 0: continue
                side = "buy" if tgt_notional>0 else "sell"
                broker.place_order(sym, side, qty, px)
                logger.info(f"order {sym} side={side} qty={qty:.6f} px={px:.2f} equity={equity:.2f}")
            except Exception as e:
                logger.exception(f"live loop error for {sym}: {e}")
        time.sleep(poll)
