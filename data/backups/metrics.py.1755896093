from __future__ import annotations
import numpy as np

def equity_curve(ret_series: np.ndarray, start_equity: float = 1.0) -> np.ndarray:
    r = np.asarray(ret_series, dtype=float)
    eq = [start_equity]
    for x in r:
        eq.append(eq[-1]*(1.0+x))
    return np.asarray(eq[1:], float)

def max_drawdown(equity: np.ndarray) -> float:
    eq = np.asarray(equity, float)
    if eq.size == 0:
        return 0.0
    peaks = np.maximum.accumulate(eq)
    dd = (eq - peaks) / peaks
    return float(-dd.min()*100.0)

def hitrate(pnl_per_trade: np.ndarray) -> float:
    t = np.asarray(pnl_per_trade, float)
    t = t[np.abs(t) > 1e-12]
    return float((t > 0).mean()*100.0) if t.size else 0.0

def profit_factor(pnl_per_trade: np.ndarray) -> float:
    t = np.asarray(pnl_per_trade, float)
    t = t[np.abs(t) > 1e-12]
    if t.size == 0:
        return 0.0
    gains = t[t > 0].sum()
    losses = -t[t < 0].sum()
    if losses == 0.0:
        return float("inf") if gains > 0 else 0.0
    return float(gains / losses)

def sharpe_ratio(returns_per_bar: np.ndarray, periods_per_year: int = 252) -> float:
    r = np.asarray(returns_per_bar, float)
    if r.size == 0:
        return 0.0
    mu = r.mean()
    sd = r.std(ddof=1)
    if sd == 0:
        return 0.0
    return float((mu/sd) * np.sqrt(periods_per_year))
