from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.io import load_history

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

def load_cfg(p: Path): 
    with open(p,"r") as f: 
        return yaml.safe_load(f)

def load_model(symbol, tf):
    clf = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    meta = json.load(open(MODEL_DIR / f"pro_{symbol}_{tf}.json"))
    feats = meta.get("feats") or ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]
    return clf, feats

def map_triplet(clf, proba):
    out = np.zeros((proba.shape[0],3))
    cls = getattr(clf,"classes_",[-1,0,1])
    pos = {-1:0, 0:1, 1:2}
    for j,c in enumerate(cls):
        out[:, pos[int(c)]] = proba[:, j]
    return out

def run_wf(df, p3, fee_bps, is_frac, oos_frac):
    n = len(df); i = 0; wins = []
    r = df["ret1"].values
    step = 0.02
    grid = np.round(np.arange(0.00, 0.13 + 1e-9, step), 2)
    while i + int(n*oos_frac) < n:
        is_end = i + int(n*is_frac)
        oos_end = min(n, is_end + int(n*oos_frac))
        is_p, oos_p = p3[i:is_end], p3[is_end:oos_end]

        best_tb, best_ts, best_s = 0.05, 0.05, -1e9
        for tb in grid:
            for ts in grid:
                sig = np.where(is_p[:,2] >= tb, 1, np.where(is_p[:,0] >= ts, -1, 0))
                fees = (np.diff(np.r_[0, sig]) != 0) * (fee_bps/10000.0)
                pnl = sig[:-1]*r[i+1:is_end] - fees[:-1]
                sd = pnl.std(ddof=1)
                if sd > 0:
                    s = pnl.mean()/sd * np.sqrt(252)
                    if s > best_s:
                        best_s, best_tb, best_ts = s, float(tb), float(ts)

        sig = np.where(oos_p[:,2] >= best_tb, 1, np.where(oos_p[:,0] >= best_ts, -1, 0))
        fees = (np.diff(np.r_[0, sig]) != 0) * (fee_bps/10000.0)
        pnl = sig[:-1]*r[is_end+1:oos_end] - fees[:-1]
        eq = (1 + pnl).cumprod()
        hr = float((pnl > 0).mean()*100) if len(pnl) else 0.0
        dd = float(((eq/np.maximum.accumulate(eq))-1).min()*100) if len(eq) else 0.0
        pf = float(pnl[pnl>0].sum()/max(1e-12, -pnl[pnl<0].sum())) if len(pnl) else 0.0
        shp = float(pnl.mean()/pnl.std(ddof=1)*np.sqrt(252)) if pnl.std(ddof=1) > 0 else 0.0
        wins.append({"tb":best_tb,"ts":best_ts,"PnL": (eq[-1]-1)*100 if len(eq) else 0, "HR":hr, "DD":dd, "PF":pf, "Sharpe":shp})
        i = oos_end
    return wins

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", required=True)
    ap.add_argument("--symbols", nargs="+", required=True)
    ap.add_argument("--tfs", nargs="+", required=True)
    ap.add_argument("--wf_is_frac", type=float, default=0.6)
    ap.add_argument("--wf_oos_frac", type=float, default=0.2)
    ap.add_argument("--fee_bps", type=float, default=0.0)
    args = ap.parse_args()
    cfg = load_cfg(Path(args.config))
    for s in args.symbols:
        for tf in args.tfs:
            try:
                clf, feats = load_model(s, tf)
                df = load_history(DATA_DIR, s, tf).reset_index(drop=True)
                X = df[feats].astype(float).fillna(0.0).values
                p3 = map_triplet(clf, clf.predict_proba(X))
                wins = run_wf(df, p3, args.fee_bps, args.wf_is_frac, args.wf_oos_frac)
                o = OUT_DIR / f"bt_{s}_{tf}_wf.json"
                json.dump({"symbol":s,"tf":tf,"windows":wins}, open(o,"w"), indent=2)
                if wins:
                    avg_tb = sum(w["tb"] for w in wins)/len(wins)
                    avg_ts = sum(w["ts"] for w in wins)/len(wins)
                    pnl = sum(w["PnL"] for w in wins)
                    hr  = sum(w["HR"] for w in wins)/len(wins)
                    dd  = min(w["DD"] for w in wins)
                    pf_vals = [w["PF"] for w in wins if w["PF"]>0]
                    pf = (sum(pf_vals)/len(pf_vals)) if pf_vals else 0
                    shp = sum(w["Sharpe"] for w in wins)/len(wins)
                    print(f"[WF] {o}  OOS PnL={pnl:.3f}%  HR={hr:.2f}%  DD={dd:.2f}%  PF={'inf' if pf>1e9 else f'{pf:.2f}'}  Sharpe={shp:.2f}  avg_thr=({avg_tb:.2f},{avg_ts:.2f})  fee={args.fee_bps:.2f}bps  windows={len(wins)}")
            except Exception as e:
                print(f"[FAIL WF] {s} {tf}: {e}")
if __name__ == "__main__":
    main()
