from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.metrics import equity_curve, max_drawdown, hitrate, profit_factor, sharpe_ratio

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: return yaml.safe_load(f)

def load_df(symbol, tf):
    p = DATA_DIR / f"{symbol}_{tf}.csv"
    if not p.exists(): raise FileNotFoundError(p)
    return pd.read_csv(p).sort_values("time").reset_index(drop=True)

def make_features(df: pd.DataFrame):
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(48, min_periods=12).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"]  = z["ema12"] - z["ema26"]
    d = z["close"].diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up/(down+1e-12)
    z["rsi14"] = 100 - (100/(1+rs))
    hl = z["high"]-z["low"]
    hc = (z["high"]-z["close"].shift()).abs()
    lc = (z["low"]-z["close"].shift()).abs()
    tr = pd.concat([hl,hc,lc], axis=1).max(axis=1)
    z["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean()/(z["close"]+1e-12)
    z["ema_gap"] = (z["close"]-z["ema12"])/(z["ema12"]+1e-12)
    z = z.dropna().reset_index(drop=True)
    return z

def label_future(df: pd.DataFrame, horizon=1):
    fut = df["close"].shift(-horizon)/df["close"] - 1.0
    return fut

def vector_sign_from_proba(p: np.ndarray, thr_long: float, thr_short: float) -> np.ndarray:
    """
    p shape: (N, 3) with columns ordered [-1, 0, 1].
    score = p1 - p-1. Go long if score > thr_long; short if score < -thr_short; else flat.
    """
    p_minus = p[:,0]; p_zero = p[:,1]; p_plus = p[:,2]
    score = p_plus - p_minus
    sign = np.where(score > thr_long, 1.0, np.where(score < -thr_short, -1.0, 0.0))
    return sign, score

def apply_costs(ret_bar: np.ndarray, sign: np.ndarray, fee_bps: float) -> np.ndarray:
    """
    Vähennä kulut vain kun positio avataan/suljetaan tai käännetään.
    fee_bps on round-turn per tapahtuma (bps). Käännös samassa baarissa -> 2*fee_bps.
    """
    fee = fee_bps/10000.0
    prev = np.concatenate([[0.0], sign[:-1]])
    entry = (prev==0.0) & (sign!=0.0)
    exit_  = (prev!=0.0) & (sign==0.0)
    flip = (prev!=0.0) & (sign!=0.0) & (np.sign(prev)!=np.sign(sign))
    cost = np.zeros_like(ret_bar)
    cost[entry] += fee
    cost[exit_] += fee
    cost[flip]  += 2*fee
    return ret_bar - cost

def evaluate(prices: np.ndarray, sign: np.ndarray, horizon: int, tf: str,
             fee_bps: float) -> dict:
    valid_n = len(prices) - horizon
    fut = prices[horizon:valid_n+horizon] / prices[:valid_n] - 1.0
    sign = sign[:valid_n].astype(float)
    ret = sign * fut
    if fee_bps != 0.0:
        ret = apply_costs(ret, sign, fee_bps)
    eq = equity_curve(ret, 1.0)
    # treidit (ketjutus yhtä suuntaa)
    trades = []
    cur = 0.0; acc = 0.0
    for s, r in zip(sign, ret):
        if cur==0.0 and s!=0.0: cur, acc = s, r
        elif cur!=0.0 and s==cur: acc += r
        elif cur!=0.0 and s!=cur:
            trades.append(acc); cur = s; acc = 0.0 if s==0.0 else r
    if cur!=0.0: trades.append(acc)
    pnl_tr = np.asarray(trades, float)

    total_pnl = float(100.0*ret.sum())
    hr = hitrate(pnl_tr)
    dd = max_drawdown(eq)

    tf_map = {"15m": 2496, "1h": 624, "4h": 156}
    sharpe = sharpe_ratio(ret, tf_map.get(tf, 252))
    pf = profit_factor(pnl_tr)

    return dict(PnL=total_pnl, HitRate=hr, MaxDD=dd,
                Sharpe=float(sharpe), ProfitFactor=float(pf),
                trades=int(len(pnl_tr)), n_points=int(valid_n))

def backtest_one(symbol: str, tf: str, cfg: dict,
                 thr_long: float, thr_short: float,
                 fee_bps: float, optimize: bool) -> dict:
    df = load_df(symbol, tf)
    z = make_features(df)
    horizon = int((cfg.get("train",{}) or {}).get("horizon_bars",1))
    prices = z["close"].values
    X = z[FEATS].values
    valid_n = len(prices)-horizon
    if valid_n <= 50: raise RuntimeError("Too short series")

    pipe = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    # batch-proba kerralla (NOPEA)
    proba = pipe.predict_proba(X[:valid_n])  # shape (N, 3) order matches classes_
    # varmista järjestys [-1,0,1]
    cls = list(pipe.classes_)
    order = [cls.index(-1), cls.index(0), cls.index(1)]
    p = proba[:, order]

    # thresholdit — valinnainen grid‑optimointi IS‑ikkunassa
    if optimize:
        grid = np.linspace(0.0, 0.30, 16)  # 0…30% erotus
        best = None
        split = int(0.6*valid_n)
        for a in grid:
            for b in grid:
                sign_is, _ = vector_sign_from_proba(p[:split], a, b)
                res_is = evaluate(prices[:split+horizon], sign_is, horizon, tf, fee_bps)
                score = res_is["Sharpe"]  # vaihtoehtoisesti PF/PnL
                if (best is None) or (score > best[0]):
                    best = (score, a, b)
        thr_long, thr_short = best[1], best[2]

    sign, score = vector_sign_from_proba(p, thr_long, thr_short)
    res = evaluate(prices, sign, horizon, tf, fee_bps)
    res.update(dict(symbol=symbol, tf=tf, thr_long=thr_long, thr_short=thr_short,
                    fee_bps=fee_bps))

    outp = OUT_DIR / f"bt_{symbol}_{tf}.json"
    outp.write_text(json.dumps(res, indent=2))
    pf = res["ProfitFactor"]; pf_str = "inf" if np.isinf(pf) else f"{pf:.2f}"
    print(f"[BT] {outp}  PnL={res['PnL']:.3f}%  HR={res['HitRate']:.2f}%  DD={res['MaxDD']:.2f}%  PF={pf_str}  Sharpe={res['Sharpe']:.2f}  thr=({thr_long:.2f},{thr_short:.2f})  fee={fee_bps:.2f}bps")
    return res

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="config.yaml")
    ap.add_argument("--symbols", nargs="*", default=None)
    ap.add_argument("--tfs", nargs="*", default=None)
    ap.add_argument("--thr_long", type=float, default=0.05, help="p(1)-p(-1) kynnys longille")
    ap.add_argument("--thr_short", type=float, default=0.05, help="p(1)-p(-1) kynnys shortille")
    ap.add_argument("--fee_bps", type=float, default=0.0, help="round-turn kustannus bps/treidi (entry/exit huomioidaan)")
    ap.add_argument("--optimize_thresholds", action="store_true", help="grid‑optimoi thr long/short IS-splitissä")
    args = ap.parse_args()

    cfg = load_cfg(Path(args.config))
    symbols = args.symbols or ((cfg.get("market",{}) or {}).get("symbols") or [])
    tfs = args.tfs or ((cfg.get("train",{}) or {}).get("timeframes") or ["15m","1h","4h"])

    for s in symbols:
        for tf in tfs:
            try:
                backtest_one(s, tf, cfg, args.thr_long, args.thr_short,
                             args.fee_bps, args.optimize_thresholds)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")

if __name__ == "__main__":
    main()
