from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.io import load_history

# valinnaiset "suojafeats", jos metassa ei ole "feats"
DEFAULT_FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

# metrit
def equity_curve(ret_series: np.ndarray, start_equity: float = 1.0) -> np.ndarray:
    r = np.asarray(ret_series, dtype=float)
    eq = [start_equity]
    for x in r: eq.append(eq[-1]*(1.0+x))
    return np.asarray(eq[1:], float)

def max_drawdown(equity: np.ndarray) -> float:
    eq = np.asarray(equity, float)
    if eq.size == 0: return 0.0
    peaks = np.maximum.accumulate(eq)
    dd = (eq - peaks) / peaks
    return float(-dd.min()*100.0)

def hitrate(pnl: np.ndarray) -> float:
    p = np.asarray(pnl, float)
    return float((p>0).mean()*100.0) if p.size else 0.0

def profit_factor(pnl: np.ndarray) -> float:
    p = np.asarray(pnl, float)
    gains = p[p>0].sum()
    losses = -p[p<0].sum()
    return float(gains / (losses if losses>0 else 1e-12))

def sharpe_ratio(pnl: np.ndarray, periods_per_year: int = 252) -> float:
    p = np.asarray(pnl, float)
    if p.size == 0: return 0.0
    mu, sd = p.mean(), p.std(ddof=1)
    return float((mu/sd)*np.sqrt(periods_per_year)) if sd>0 else 0.0

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: return yaml.safe_load(f)

def load_model(symbol: str, tf: str):
    clf = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    feats = DEFAULT_FEATS
    meta_p = MODEL_DIR / f"pro_{symbol}_{tf}.json"
    if meta_p.exists():
        meta = json.load(open(meta_p))
        feats = meta.get("feats") or meta.get("features") or feats
    return clf, feats

def ensure_features(df: pd.DataFrame) -> pd.DataFrame:
    z = df.copy()
    if "ret1" not in z:  z["ret1"] = z["close"].pct_change()
    if "ret5" not in z:  z["ret5"] = z["close"].pct_change(5)
    if "vol5" not in z:  z["vol5"] = z["ret1"].rolling(5).std().fillna(0.0)
    if "ema12" not in z: z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    if "ema26" not in z: z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    if "macd" not in z:  z["macd"] = z["ema12"] - z["ema26"]
    if "rsi14" not in z:
        diff = z["close"].diff()
        up = diff.clip(lower=0).rolling(14).mean()
        dn = (-diff.clip(upper=0)).rolling(14).mean()
        rs = up / dn.replace(0, np.nan)
        z["rsi14"] = 100 - (100 / (1 + rs))
    if "atr14" not in z:
        if {"high","low","close"}.issubset(z.columns):
            tr = np.maximum(z["high"]-z["low"], np.maximum((z["high"]-z["close"].shift()).abs(), (z["low"]-z["close"].shift()).abs()))
            z["atr14"] = tr.rolling(14).mean()
        else:
            z["atr14"] = 0.0
    if "ema_gap" not in z: z["ema_gap"] = (z["close"] - z["ema12"]) / z["ema12"]
    return z

def proba_triplet(clf, X: np.ndarray) -> np.ndarray:
    P = clf.predict_proba(X)
    out = np.zeros((P.shape[0], 3), dtype=float)
    cls = getattr(clf, "classes_", [-1,0,1])
    pos = {-1:0, 0:1, 1:2}
    for j, c in enumerate(cls):
        out[:, pos[int(c)]] = P[:, j]
    return out

def simulate_one(symbol: str, tf: str, args):
    clf, feats = load_model(symbol, tf)
    df = ensure_features(load_history(DATA_DIR, symbol, tf)).reset_index(drop=True)
    X = df[feats].astype(float).fillna(0.0).values
    p3 = proba_triplet(clf, X)

    tb = args.thr_buy if args.thr_buy is not None else 0.05
    ts = args.thr_sell if args.thr_sell is not None else 0.05

    if args.optimize_thresholds:
        grid = np.round(np.arange(0.00, 0.12+1e-9, 0.02), 2)
        best, best_s = (tb, ts), -1e9
        r_is = df["ret1"].values
        for b in grid:
            for s in grid:
                sig = np.where(p3[:,2] >= b, 1, np.where(p3[:,0] >= s, -1, 0))
                fees = (np.diff(np.r_[0, sig]) != 0) * (args.fee_bps/10000.0)
                pnl = sig[:-1] * r_is[1:] - fees[:-1]
                sd = pnl.std(ddof=1)
                s_val = (pnl.mean()/sd*np.sqrt(252)) if sd>0 else -1e9
                if s_val > best_s:
                    best_s, best = s_val, (float(b), float(s))
        tb, ts = best

    sig = np.where(p3[:,2] >= tb, 1, np.where(p3[:,0] >= ts, -1, 0)).astype(int)
    r = df["ret1"].values
    fees = (np.diff(np.r_[0, sig]) != 0) * (args.fee_bps/10000.0)
    pnl = sig[:-1] * r[1:] - fees[:-1]

    eq = equity_curve(pnl, 1.0)
    out = {
        "symbol": symbol, "tf": tf,
        "thr_buy": tb, "thr_sell": ts, "fee_bps": args.fee_bps,
        "metrics": {
            "PnL%": (float(eq[-1])-1.0)*100.0 if len(eq) else 0.0,
            "HR%": hitrate(pnl),
            "DD%": max_drawdown(eq),
            "PF": profit_factor(pnl),
            "Sharpe": sharpe_ratio(pnl, 252),
        }
    }
    o = OUT_DIR / f"bt_{symbol}_{tf}.json"
    json.dump(out, open(o, "w"), indent=2)
    m = out["metrics"]
    print(f"[BT] {o}  PnL={m['PnL%']:.3f}%  HR={m['HR%']:.2f}%  DD={m['DD%']:.2f}%  PF={m['PF']:.2f}  Sharpe={m['Sharpe']:.2f}  thr=({tb:.2f},{ts:.2f})  fee={args.fee_bps:.2f}bps")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", required=True)
    ap.add_argument("--symbols", nargs="+", required=True)
    ap.add_argument("--tfs", nargs="+", required=True)
    ap.add_argument("--fee_bps", type=float, default=0.0)
    ap.add_argument("--thr_buy", type=float, default=None)
    ap.add_argument("--thr_sell", type=float, default=None)
    ap.add_argument("--optimize_thresholds", action="store_true")
    args = ap.parse_args()
    _ = load_cfg(Path(args.config))  # luetaan jos haluat jatkossa
    for s in args.symbols:
        for tf in args.tfs:
            try:
                simulate_one(s, tf, args)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")
if __name__ == "__main__":
    main()
