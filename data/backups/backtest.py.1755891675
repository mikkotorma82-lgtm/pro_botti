from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load

from core.cooldown import apply_cooldown, apply_flip_guard

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p, "r") as f:
        return yaml.safe_load(f)

def make_features(df: pd.DataFrame) -> pd.DataFrame:
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(5).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"] = z["ema12"] - z["ema26"]
    # RSI
    d = z["close"].diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up / (down + 1e-12)
    z["rsi14"] = 100 - 100/(1+rs)
    # ATR
    hl = z["high"] - z["low"]
    hc = (z["high"] - z["close"].shift()).abs()
    lc = (z["low"] - z["close"].shift()).abs()
    tr = pd.concat([hl, hc, lc], axis=1).max(axis=1)
    z["atr14"] = tr.rolling(14).mean()
    z["ema_gap"] = (z["close"] - z["ema12"]) / (z["ema12"] + 1e-12)
    return z

def proba_map(clf, Xrow: np.ndarray) -> dict:
    classes = list(map(int, clf.classes_))
    p = clf.predict_proba(Xrow)[0]
    return {int(c): float(p[i]) for i, c in enumerate(classes)}

def simulate_one(symbol: str, tf: str, args, cfg):
    # Data
    csv = DATA_DIR / f"{symbol}_{tf}.csv"
    df = pd.read_csv(csv).sort_values("time").reset_index(drop=True)
    z = make_features(df)
    z = z.dropna().reset_index(drop=True)

    # Malli
    model_path = MODEL_DIR / f"pro_{symbol}_{tf}.joblib"
    clf = load(model_path)

    # Thresholdit
    thr_b = getattr(args, "thr_buy", None)
    thr_s = getattr(args, "thr_sell", None)
    if thr_b is None or thr_s is None:
        thr_b = thr_s = 0.05
    # Kulut (bps -> suhteellinen)
    fee_bps = float(getattr(args, "fee_bps", 0.0))
    fee_rt = fee_bps * 1e-4  # per round‑turn
    half_fee = 0.5 * fee_rt

    # Cooldown-parametrit
    cd = int(getattr(args, "cooldown_bars", 0))
    flip_guard = int(getattr(args, "flip_guard_bars", 0))

    # Luo signaalit (raaka)
    sig_raw = np.zeros(len(z), dtype=int)
    feats = z[FEATS].values
    for i in range(len(z)):
        X = feats[i:i+1]
        pm = proba_map(clf, X)
        pbuy = pm.get(1, 0.0); psell = pm.get(-1, 0.0)
        # diskriminaattori: p(1)-p(-1) vs kynnys
        if (pbuy - psell) >= thr_b:
            sig_raw[i] = 1
        elif (psell - pbuy) >= thr_s:
            sig_raw[i] = -1
        else:
            sig_raw[i] = 0

    # Sovella cooldown + flip guard
    sig = sig_raw.copy()
    if cd > 0:
        sig = apply_cooldown(sig, cd)
    if flip_guard > 0:
        sig = apply_flip_guard(sig, flip_guard)

    # Yksinkertainen simulaatio: avaa kun sig!=0 ja positio tyhjä / vastakkainen -> vaihto
    pos = 0
    entry_px = 0.0
    pnl_series = []
    for i in range(1, len(z)):
        px_prev = float(z.loc[i-1, "close"])
        px = float(z.loc[i, "close"])

        want = int(sig[i])
        trade_ret = 0.0
        # Jos signaali vaihtuu tai uusi suunta
        if want != 0 and want != pos:
            # sulje vanha
            if pos != 0:
                edge = (px - entry_px)/entry_px if pos>0 else (entry_px - px)/entry_px
                edge -= half_fee  # ulos
                trade_ret += edge
            # avaa uusi
            pos = want
            entry_px = px
            trade_ret -= half_fee  # sisään

        # P&L seuraa vain toteutuneista siirroista (edge on jo kirjattu yllä)
        pnl_series.append(trade_ret)

    pnl_arr = np.asarray(pnl_series, float)
    eq = np.cumprod(1.0 + pnl_arr)
    if eq.size == 0:
        total = 0.0; dd = 0.0; hr = 0.0; pf = 0.0; sharpe = 0.0
    else:
        total = (eq[-1]-1.0)*100.0
        # Max DD
        peaks = np.maximum.accumulate(eq)
        dd = float( -( (eq - peaks) / peaks ).min() * 100.0 )
        # Hit rate: laske vain !=0 trade_ret
        trades = pnl_arr[np.abs(pnl_arr) > 1e-12]
        hr = float( (trades>0).mean()*100.0 ) if trades.size else 0.0
        # Profit factor
        gains = trades[trades>0].sum()
        losses = -trades[trades<0].sum()
        pf = float(gains / losses) if losses>0 else float("inf") if gains>0 else 0.0
        # Sharpe (päiväisten baariin normitus karkea: 252)
        mu = pnl_arr.mean(); sd = pnl_arr.std(ddof=1)
        sharpe = float( (mu/sd)*np.sqrt(252) ) if sd>0 else 0.0

    outp = OUT_DIR / f"bt_{symbol}_{tf}.json"
    with open(outp, "w") as f:
        json.dump({
            "symbol": symbol, "tf": tf,
            "pnl_pct": total, "hit_rate_pct": hr, "max_dd_pct": dd,
            "profit_factor": pf, "sharpe": sharpe,
            "thr": [thr_b, thr_s], "fee_bps": fee_bps,
            "cooldown_bars": cd, "flip_guard_bars": flip_guard
        }, f, indent=2)

    label = f"[BT] {outp}  PnL={total:.3f}%  HR={hr:.2f}%  DD={dd:.2f}%  PF={pf:.2f}  Sharpe={sharpe:.2f}  thr=({thr_b:.2f},{thr_s:.2f})  fee={fee_bps:.2f}bps  cd={cd}"
    print(label)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", required=True)
    ap.add_argument("--symbols", nargs="+", required=True)
    ap.add_argument("--tfs", nargs="+", required=True)
    ap.add_argument("--fee_bps", type=float, default=0.0)
    ap.add_argument("--thr_buy", type=float, default=None)
    ap.add_argument("--thr_sell", type=float, default=None)
    ap.add_argument("--cooldown_bars", type=int, default=0)
    ap.add_argument("--flip_guard_bars", type=int, default=0)
    args = ap.parse_args()

    cfg = load_cfg(Path(args.config))
    for s in args.symbols:
        for tf in args.tfs:
            try:
                simulate_one(s, tf, args, cfg)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")

if __name__ == "__main__":
    main()
