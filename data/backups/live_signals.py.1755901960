from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.io import load_history

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"

DEFAULT_FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p, "r") as f:
        return yaml.safe_load(f)

def load_model(symbol: str, tf: str):
    clf = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    feats = DEFAULT_FEATS
    meta_p = MODEL_DIR / f"pro_{symbol}_{tf}.json"
    if meta_p.exists():
        try:
            meta = json.load(open(meta_p, "r")) or {}
            feats = meta.get("feats", feats) or feats
        except Exception:
            pass
    return clf, feats

def _ensure_features(df: pd.DataFrame) -> pd.DataFrame:
    need = set(DEFAULT_FEATS)
    if need.issubset(df.columns):
        return df
    # build minimal features from OHLCV
    close = pd.to_numeric(df["close"], errors="coerce")
    high  = pd.to_numeric(df.get("high", close), errors="coerce")
    low   = pd.to_numeric(df.get("low", close), errors="coerce")
    open_ = pd.to_numeric(df.get("open", close), errors="coerce")

    ret1 = close.pct_change(1)
    ret5 = close.pct_change(5)
    vol5 = close.pct_change(1).rolling(5).std()

    ema12 = close.ewm(span=12, adjust=False).mean()
    ema26 = close.ewm(span=26, adjust=False).mean()
    macd = ema12 - ema26
    ema_gap = (ema12 - ema26) / (ema26.replace(0, np.nan))

    delta = close.diff()
    gain = delta.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    loss = (-delta.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = gain / (loss.replace(0, np.nan))
    rsi14 = 100 - (100 / (1 + rs))

    prev_close = close.shift(1)
    tr = pd.concat([
        (high - low).abs(),
        (high - prev_close).abs(),
        (low  - prev_close).abs()
    ], axis=1).max(axis=1)
    atr14 = tr.ewm(alpha=1/14, adjust=False).mean()

    df = df.copy()
    df["ret1"] = ret1
    df["ret5"] = ret5
    df["vol5"] = vol5
    df["ema12"] = ema12
    df["ema26"] = ema26
    df["macd"] = macd
    df["rsi14"] = rsi14
    df["atr14"] = atr14
    df["ema_gap"] = ema_gap
    return df.fillna(0.0)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", required=True)
    ap.add_argument("--symbols", nargs="+", required=True)
    ap.add_argument("--tf", required=True)
    ap.add_argument("--thr_buy", type=float, default=0.05)
    ap.add_argument("--thr_sell", type=float, default=0.05)
    ap.add_argument("--fee_bps", type=float, default=None)
    args = ap.parse_args()

    _ = load_cfg(Path(args.config))  # reserved

    out = []
    for s in args.symbols:
        try:
            clf, feats = load_model(s, args.tf)
            df = load_history(DATA_DIR, s, args.tf)
            df = _ensure_features(df)
            X = df[feats].iloc[[-1]].to_numpy(dtype=float)

            probs = clf.predict_proba(X)[0]
            classes = [str(c) for c in clf.classes_]
            proba_map = {c: float(p) for c, p in zip(classes, probs)}

            pneg = proba_map.get("-1", 0.0)
            p0   = proba_map.get("0",  0.0)
            ppos = proba_map.get("1",  0.0)

            if ppos >= max(pneg, p0) and ppos >= args.thr_buy:
                sig = 1
            elif pneg >= max(ppos, p0) and pneg >= args.thr_sell:
                sig = -1
            else:
                sig = 0

            item = {
                "symbol": s,
                "tf": args.tf,
                "time": str(int(pd.Timestamp.utcnow().timestamp())),
                "price": float(df["close"].iloc[-1]),
                "signal": int(sig),
                "proba": {"-1": pneg, "0": p0, "1": ppos},
                "features_used": feats,
            }
            if args.fee_bps is not None:
                item["fee_bps"] = float(args.fee_bps)
            out.append(item)
        except Exception as e:
            out.append({"symbol": s, "tf": args.tf, "error": str(e)})

    print(json.dumps(out, indent=2))

if __name__ == "__main__":
    main()
