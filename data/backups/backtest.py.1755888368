from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.metrics import equity_curve, max_drawdown, hitrate, profit_factor, sharpe_ratio

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: return yaml.safe_load(f)

def load_df(symbol, tf):
    p = DATA_DIR / f"{symbol}_{tf}.csv"
    if not p.exists(): raise FileNotFoundError(p)
    return pd.read_csv(p).sort_values("time").reset_index(drop=True)

def make_features(df: pd.DataFrame):
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(48, min_periods=12).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"]  = z["ema12"] - z["ema26"]
    d = z["close"].diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up/(down+1e-12)
    z["rsi14"] = 100 - (100/(1+rs))
    hl = z["high"]-z["low"]
    hc = (z["high"]-z["close"].shift()).abs()
    lc = (z["low"]-z["close"].shift()).abs()
    tr = pd.concat([hl,hc,lc], axis=1).max(axis=1)
    z["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean()/(z["close"]+1e-12)
    z["ema_gap"] = (z["close"]-z["ema12"])/(z["ema12"]+1e-12)
    z = z.dropna().reset_index(drop=True)
    return z

def equity_periods(tf: str) -> int:
    return {"15m": 2496, "1h": 624, "4h": 156}.get(tf, 252)

def safe_align_proba(clf, X: np.ndarray) -> np.ndarray:
    """
    Palauttaa Nx3 proba-matriisin järjestyksessä [-1, 0, 1].
    Jos jokin luokka puuttuu clf.classes_ listasta, täytetään eps:llä ja normalisoidaan.
    """
    proba = clf.predict_proba(X)           # shape (N, K)
    classes = np.array(clf.classes_)       # esim. [-1, 1] jos 0 puuttuu
    idx = {c:i for i,c in enumerate(classes)}
    N = proba.shape[0]
    p = np.full((N, 3), 1e-12, dtype=float)  # eps
    for j, c in enumerate([-1, 0, 1]):
        if c in idx:
            p[:, j] = proba[:, idx[c]]
    p /= p.sum(1, keepdims=True)
    return p  # columns: [-1,0,1]

def vector_sign_from_proba(p: np.ndarray, thr_long: float, thr_short: float):
    # p columns: [-1,0,1]
    score = p[:,2] - p[:,0]
    sign = np.where(score > thr_long, 1.0, np.where(score < -thr_short, -1.0, 0.0))
    return sign, score

def apply_costs(ret_bar: np.ndarray, sign: np.ndarray, fee_bps: float) -> np.ndarray:
    fee = fee_bps/10000.0
    prev = np.concatenate([[0.0], sign[:-1]])
    entry = (prev==0.0) & (sign!=0.0)
    exit_  = (prev!=0.0) & (sign==0.0)
    flip   = (prev!=0.0) & (sign!=0.0) & (np.sign(prev)!=np.sign(sign))
    cost = np.zeros_like(ret_bar)
    cost[entry] += fee
    cost[exit_]  += fee
    cost[flip]   += 2*fee
    return ret_bar - cost

def evaluate(prices: np.ndarray, sign: np.ndarray, horizon: int, tf: str, fee_bps: float) -> dict:
    valid_n = len(prices) - horizon
    fut = prices[horizon:valid_n+horizon] / prices[:valid_n] - 1.0
    sign = sign[:valid_n].astype(float)
    ret = sign * fut
    if fee_bps != 0.0:
        ret = apply_costs(ret, sign, fee_bps)

    eq = equity_curve(ret, 1.0)
    trades = []
    cur = 0.0; acc = 0.0
    for s, r in zip(sign, ret):
        if cur==0.0 and s!=0.0: cur, acc = s, r
        elif cur!=0.0 and s==cur: acc += r
        elif cur!=0.0 and s!=cur:
            trades.append(acc); cur = s; acc = 0.0 if s==0.0 else r
    if cur!=0.0: trades.append(acc)
    pnl_tr = np.asarray(trades, float)

    total_pnl = float(100.0*ret.sum())
    hr = hitrate(pnl_tr)
    dd = max_drawdown(eq)
    sharpe = sharpe_ratio(ret, equity_periods(tf))
    pf = profit_factor(pnl_tr)

    return dict(PnL=total_pnl, HitRate=hr, MaxDD=dd, Sharpe=float(sharpe),
                ProfitFactor=float(pf), trades=int(len(pnl_tr)), n_points=int(valid_n))

def backtest_one(symbol: str, tf: str, cfg: dict, thr_long: float, thr_short: float,
                 fee_bps: float, optimize: bool) -> dict:
    df = load_df(symbol, tf)
    z = make_features(df)
    horizon = int((cfg.get("train",{}) or {}).get("horizon_bars",1))
    prices = z["close"].values
    X = z[FEATS].values
    valid_n = len(prices)-horizon
    if valid_n <= 50: raise RuntimeError("Too short series")

    model = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    p = safe_align_proba(model, X[:valid_n])  # Nx3

    if optimize:
        grid = np.linspace(0.0, 0.30, 16)
        best = None
        split = int(0.6*valid_n)
        for a in grid:
            for b in grid:
                sign_is, _ = vector_sign_from_proba(p[:split], a, b)
                res_is = evaluate(prices[:split+horizon], sign_is, horizon, tf, fee_bps)
                score = res_is["Sharpe"]
                if (best is None) or (score > best[0]): best = (score, a, b)
        thr_long, thr_short = best[1], best[2]

    sign, score = vector_sign_from_proba(p, thr_long, thr_short)
    res = evaluate(prices, sign, horizon, tf, fee_bps)
    res.update(dict(symbol=symbol, tf=tf, thr_long=thr_long, thr_short=thr_short, fee_bps=fee_bps))
    outp = OUT_DIR / f"bt_{symbol}_{tf}.json"
    outp.write_text(json.dumps(res, indent=2))
    pf = res["ProfitFactor"]; pf_str = "inf" if np.isinf(pf) else f"{pf:.2f}"
    print(f"[BT] {outp}  PnL={res['PnL']:.3f}%  HR={res['HitRate']:.2f}%  DD={res['MaxDD']:.2f}%  PF={pf_str}  Sharpe={res['Sharpe']:.2f}  thr=({thr_long:.2f},{thr_short:.2f})  fee={fee_bps:.2f}bps")
    return res

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="config.yaml")
    ap.add_argument("--symbols", nargs="*", default=None)
    ap.add_argument("--tfs", nargs="*", default=None)
    ap.add_argument("--thr_long", type=float, default=0.05)
    ap.add_argument("--thr_short", type=float, default=0.05)
    ap.add_argument("--fee_bps", type=float, default=0.0)
    ap.add_argument("--optimize_thresholds", action="store_true")
    args = ap.parse_args()

    cfg = load_cfg(Path(args.config))
    symbols = args.symbols or ((cfg.get("market",{}) or {}).get("symbols") or [])
    tfs = args.tfs or ((cfg.get("train",{}) or {}).get("timeframes") or ["15m","1h","4h"])
    for s in symbols:
        for tf in tfs:
            try:
                backtest_one(s, tf, cfg, args.thr_long, args.thr_short, args.fee_bps, args.optimize_thresholds)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")

if __name__ == "__main__":
    main()
