from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.io import load_history
from core.cooldown import apply_cooldown, apply_flip_guard
from core.metrics import equity_curve, max_drawdown, hitrate, profit_factor, sharpe_ratio

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

DEFAULT_FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p, "r") as f:
        return yaml.safe_load(f)

def load_model(symbol: str, tf: str):
    clf = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    meta_p = MODEL_DIR / f"pro_{symbol}_{tf}.json"
    feats = DEFAULT_FEATS
    if meta_p.exists():
        meta = json.load(open(meta_p))
        feats = meta.get("feats") or feats
    return clf, feats

def ensure_features(df: pd.DataFrame) -> pd.DataFrame:
    z = df.copy()
    if "ret1" not in z:
        z["ret1"] = z["close"].pct_change()
    if "ret5" not in z:
        z["ret5"] = z["close"].pct_change(5)
    if "vol5" not in z:
        z["vol5"] = z["ret1"].rolling(5).std().fillna(0.0)
    if "ema12" not in z:
        z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    if "ema26" not in z:
        z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    if "macd" not in z:
        z["macd"] = z["ema12"] - z["ema26"]
    if "rsi14" not in z:
        diff = z["close"].diff()
        up = diff.clip(lower=0).rolling(14).mean()
        dn = (-diff.clip(upper=0)).rolling(14).mean()
        rs = up / dn.replace(0, np.nan)
        z["rsi14"] = 100 - (100 / (1 + rs))
    if "atr14" not in z:
        if {"high","low","close"}.issubset(z.columns):
            tr = np.maximum(z["high"]-z["low"], np.maximum((z["high"]-z["close"].shift()).abs(), (z["low"]-z["close"].shift()).abs()))
            z["atr14"] = tr.rolling(14).mean()
        else:
            z["atr14"] = 0.0
    if "ema_gap" not in z:
        z["ema_gap"] = (z["close"] - z["ema12"]) / z["ema12"]
    return z

def proba_triplet(clf, X: np.ndarray) -> np.ndarray:
    """Map model proba to columns [-1,0,1] in that order."""
    P = clf.predict_proba(X)  # (n, k)
    out = np.zeros((P.shape[0], 3), dtype=float)
    cls = getattr(clf, "classes_", [-1,0,1])
    pos = {-1:0, 0:1, 1:2}
    for j, c in enumerate(cls):
        out[:, pos[int(c)]] = P[:, j]
    return out

def simulate_one(symbol: str, tf: str, args, cfg):
    clf, feats = load_model(symbol, tf)
    df = load_history(DATA_DIR, symbol, tf)
    df = ensure_features(df)
    X = df[feats].astype(float).fillna(0.0).values
    p3 = proba_triplet(clf, X)

    # signaali
    tb = args.thr_buy if args.thr_buy is not None else 0.05
    ts = args.thr_sell if args.thr_sell is not None else 0.05
    if args.optimize_thresholds:
        grid = np.round(np.arange(0.00, 0.13 + 1e-9, 0.02), 2)
        best, best_s = (tb, ts), -1e9
        r_is = df["ret1"].values
        for b in grid:
            for s in grid:
                sig = np.where(p3[:,2] >= b, 1, np.where(p3[:,0] >= s, -1, 0))
                if args.cooldown_bars and args.cooldown_bars > 0:
                    sig = apply_cooldown(sig, args.cooldown_bars)
                if args.flip_guard_bars and args.flip_guard_bars > 0:
                    sig = apply_flip_guard(sig, args.flip_guard_bars)
                fees = (np.diff(np.r_[0, sig]) != 0) * (args.fee_bps/10000.0)
                pnl = sig[:-1] * r_is[1:] - fees[:-1]
                sd = pnl.std(ddof=1)
                s_val = (pnl.mean()/sd*np.sqrt(252)) if sd > 0 else -1e9
                if s_val > best_s:
                    best_s, best = (s_val, (float(b), float(s)))
        tb, ts = best[0], best[1]

    sig = np.where(p3[:,2] >= tb, 1, np.where(p3[:,0] >= ts, -1, 0)).astype(int)
    if args.cooldown_bars and args.cooldown_bars > 0:
        sig = apply_cooldown(sig, args.cooldown_bars)
    if args.flip_guard_bars and args.flip_guard_bars > 0:
        sig = apply_flip_guard(sig, args.flip_guard_bars)

    r = df["ret1"].values
    fees = (np.diff(np.r_[0, sig]) != 0) * (args.fee_bps/10000.0)
    pnl = sig[:-1] * r[1:] - fees[:-1]
    eq = equity_curve(pnl, 1.0)
    out = {
        "symbol": symbol, "tf": tf,
        "thr_buy": tb, "thr_sell": ts,
        "fee_bps": args.fee_bps,
        "cooldown_bars": args.cooldown_bars,
        "metrics": {
            "PnL%": (float(eq[-1]) - 1.0) * 100.0 if len(eq) else 0.0,
            "HR%": hitrate(pnl),
            "DD%": max_drawdown(eq),
            "PF": profit_factor(pnl),
            "Sharpe": sharpe_ratio(pnl, 252),
        }
    }
    o = OUT_DIR / f"bt_{symbol}_{tf}.json"
    json.dump(out, open(o, "w"), indent=2)
    m = out["metrics"]
    print(f"[BT] {o}  PnL={m['PnL%']:.3f}%  HR={m['HR%']:.2f}%  DD={m['DD%']:.2f}%  PF={m['PF']:.2f}  Sharpe={m['Sharpe']:.2f}  thr=({tb:.2f},{ts:.2f})  fee={args.fee_bps:.2f}bps  cd={args.cooldown_bars or 0}")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", required=True)
    ap.add_argument("--symbols", nargs="+", required=True)
    ap.add_argument("--tfs", nargs="+", required=True)
    ap.add_argument("--fee_bps", type=float, default=0.0)
    ap.add_argument("--thr_buy", type=float, default=None)
    ap.add_argument("--thr_sell", type=float, default=None)
    ap.add_argument("--optimize_thresholds", action="store_true")
    ap.add_argument("--cooldown_bars", type=int, default=0)
    ap.add_argument("--flip_guard_bars", type=int, default=0)
    args = ap.parse_args()
    cfg = load_cfg(Path(args.config))
    for s in args.symbols:
        for tf in args.tfs:
            try:
                simulate_one(s, tf, args, cfg)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")
if __name__ == "__main__":
    main()
