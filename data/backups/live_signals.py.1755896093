from __future__ import annotations
from core.io import load_history
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"

# Turvallinen oletuslista (voit muokata configiin myöhemmin)
DEFAULT_FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: 
        return yaml.safe_load(f)

def get_feature_list(cfg: dict, symbol: str, tf: str) -> list[str]:
    # 1) config.features.per_symbol.<SYM> tai .defaults
    feats_cfg = (cfg.get("features") or {})
    per = (feats_cfg.get("per_symbol") or {}).get(symbol)
    dft = feats_cfg.get("defaults")
    if isinstance(per, list) and per: 
        return per
    if isinstance(dft, list) and dft: 
        return dft
    # 2) fallback
    return DEFAULT_FEATS

def load_model_and_feats(symbol: str, tf: str, cfg: dict):
    clf = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    meta_path = MODEL_DIR / f"pro_{symbol}_{tf}.json"
    feats = None
    if meta_path.exists():
        try:
            with open(meta_path,"r") as f:
                meta = json.load(f)
            feats = meta.get("feats")
        except Exception:
            feats = None
    if not feats:
        feats = get_feature_list(cfg, symbol, tf)
    return clf, feats

def map_proba_to_triplet(clf, proba: np.ndarray) -> np.ndarray:
    """Palauta (N,3) matriisi aina luokille [-1,0,1] kyseisessä järjestyksessä."""
    out = np.zeros((proba.shape[0], 3), dtype=float)
    # jos estimointiputkessa on esim. VotingClassifier -> hae classes_ sieltä
    classes = getattr(clf, "classes_", None)
    if classes is None and hasattr(clf, "estimators_"):
        for est in clf.estimators_:
            if hasattr(est, "classes_"):
                classes = est.classes_
                break
    if classes is None:
        # viimeinen varakeino: oletetaan kolme saraketta jo järjestyksessä
        if proba.shape[1] == 3:
            return proba
        raise ValueError("Classifier classes_ puuttuu eikä sarakemäärä ole 3")
    # täytä sarakkeet sen mukaan mitä luokkia löytyy
    for j, c in enumerate(classes):
        if c == -1: out[:,0] = proba[:,j]
        elif c == 0: out[:,1] = proba[:,j]
        elif c == 1: out[:,2] = proba[:,j]
    return out

# ------------ BACKTEST / LIVE jakautuu tässä tiedostossa importin mukaan ------------
if __name__ == "__main__" and Path(__file__).name == "backtest.py":
    from core.metrics import equity_curve, max_drawdown, hitrate, profit_factor, sharpe_ratio

    def fees_bps(args_fee: float|None, cfg_costs: dict|None, symbol: str) -> float:
        if args_fee is not None: return float(args_fee)
        if not cfg_costs: return 0.0
        per = (cfg_costs.get("per_symbol") or {}).get(symbol, {})
        dft = (cfg_costs.get("defaults") or {})
        return float(per.get("fee_bps", dft.get("fee_bps", 0.0))) + \
               float(per.get("spread_bps", dft.get("spread_bps", 0.0))) + \
               float(per.get("slippage_bps", dft.get("slippage_bps", 0.0)))

    def simulate(df: pd.DataFrame, proba3: np.ndarray, thr_buy: float, thr_sell: float, fee_bps: float):
        sig = np.where(proba3[:,2] >= thr_buy, 1, np.where(proba3[:,0] >= thr_sell, -1, 0))
        ret = df["ret1"].values.astype(float)
        pnl = sig[:-1] * ret[1:]                         # 1 baari latenssi
        trades = (np.diff(np.r_[0, sig]) != 0).astype(int)
        cost = trades * (fee_bps/10000.0)
        pnl = pnl - cost[:len(pnl)]
        eq = equity_curve(pnl)
        return {
            "PnL": (eq[-1]-1.0)*100.0 if len(eq) else 0.0,
            "HR": hitrate(pnl),
            "DD": max_drawdown(eq),
            "PF": profit_factor(pnl),
            "Sharpe": sharpe_ratio(pnl),
        }

    def grid_thresholds(df, proba3, fee_bps):
        space = np.round(np.arange(0.00, 0.13, 0.02), 2)
        best, best_val = (0.05,0.05), -9e9
        for tb in space:
            for ts in space:
                r = simulate(df, proba3, tb, ts, fee_bps)
                if r["Sharpe"] > best_val:
                    best_val, best = r["Sharpe"], (float(tb), float(ts))
        return best

    import argparse
    def main():
        ap = argparse.ArgumentParser()
        ap.add_argument("--config", required=True)
        ap.add_argument("--symbols", nargs="+", required=True)
        ap.add_argument("--tfs", nargs="+", required=True)
        ap.add_argument("--fee_bps", type=float, default=None)
        ap.add_argument("--optimize_thresholds", action="store_true")
        ap.add_argument("--thr_buy", type=float, default=0.05)
        ap.add_argument("--thr_sell", type=float, default=0.05)
        args = ap.parse_args()
        cfg = load_cfg(Path(args.config))
        for s in args.symbols:
            for tf in args.tfs:
                try:
                    clf, feats = load_model_and_feats(s, tf, cfg)
                    df = pd.read_parquet(DATA_DIR / s / f"{s}_{tf}.parquet")
                    X = df[feats].astype(float).fillna(0.0).values
                    raw = clf.predict_proba(X)
                    proba3 = map_proba_to_triplet(clf, raw)
                    fee = fees_bps(args.fee_bps, cfg.get("costs"), s)
                    tb, ts = grid_thresholds(df, proba3, fee) if args.optimize_thresholds else (args.thr_buy, args.thr_sell)
                    res = simulate(df, proba3, tb, ts, fee)
                    out = ROOT / "data" / "backtests" / f"bt_{s}_{tf}.json"
                    out.parent.mkdir(parents=True, exist_ok=True)
                    with open(out,"w") as f: json.dump({"symbol": s, "tf": tf, "thr":[tb,ts], "fee_bps": fee, **res}, f, indent=2)
                    print(f"[BT] {out}  PnL={res['PnL']:.3f}%  HR={res['HR']:.2f}%  DD={res['DD']:.2f}%  PF={res['PF']:.2f}  Sharpe={res['Sharpe']:.2f}  thr=({tb:.2f},{ts:.2f})  fee={fee:.2f}bps")
                except Exception as e:
                    print(f"[FAIL BT] {s} {tf}: {e}")
    if __name__ == "__main__":
        main()

# ---------------------- LIVE ----------------------
elif __name__ == "__main__" and Path(__file__).name == "live_signals.py":
    def main():
        ap = argparse.ArgumentParser()
        ap.add_argument("--config", required=True)
        ap.add_argument("--symbols", nargs="+", required=True)
        ap.add_argument("--tf", required=True)
        args = ap.parse_args()
        cfg = load_cfg(Path(args.config))
        out = []
        for s in args.symbols:
            try:
                clf, feats = load_model_and_feats(s, args.tf, cfg)
                df = pd.read_parquet(DATA_DIR / s / f"{s}_{args.tf}.parquet")
                X = df[feats].astype(float).fillna(0.0).values
                raw = clf.predict_proba(X[-1:].copy())
                p = map_proba_to_triplet(clf, raw)[0]
                signal = 1 if p[2] >= 0.50 else (-1 if p[0] >= 0.50 else 0)
                out.append({
                    "symbol": s, "tf": args.tf,
                    "time": str(int(df["time"].iloc[-1])) if "time" in df else None,
                    "price": float(df["close"].iloc[-1]),
                    "signal": int(signal),
                    "proba": {"-1": float(p[0]), "0": float(p[1]), "1": float(p[2])},
                    "features_used": feats
                })
            except Exception as e:
                out.append({"symbol": s, "tf": args.tf, "error": str(e)})
        print(json.dumps(out, indent=2))
    if __name__ == "__main__":
        main()
