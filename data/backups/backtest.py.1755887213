from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np
import pandas as pd
from joblib import load
from core.metrics import max_drawdown, hitrate, profit_factor, sharpe_ratio, equity_curve

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
REPORT_DIR = ROOT / "data" / "backtests"
REPORT_DIR.mkdir(parents=True, exist_ok=True)

def load_cfg(path: Path) -> dict:
    with open(path, "r") as f:
        return yaml.safe_load(f)

def load_df(symbol: str, tf: str) -> pd.DataFrame:
    p = DATA_DIR / f"{symbol}_{tf}.csv"
    if not p.exists():
        raise FileNotFoundError(p)
    df = pd.read_csv(p).sort_values("time").reset_index(drop=True)
    return df

def make_features(df: pd.DataFrame) -> pd.DataFrame:
    # Sama featurisetti kuin trainer_v2:n perusputkessa
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(48, min_periods=12).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"]  = z["ema12"] - z["ema26"]
    # RSI (14)
    delta = z["close"].diff()
    up = delta.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-delta.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up / (down + 1e-12)
    z["rsi14"] = 100 - (100 / (1 + rs))
    # ATR suhteessa hintaan
    hl = z["high"] - z["low"]
    hc = (z["high"] - z["close"].shift()).abs()
    lc = (z["low"] - z["close"].shift()).abs()
    tr = pd.concat([hl, hc, lc], axis=1).max(axis=1)
    z["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean() / (z["close"] + 1e-12)
    z["ema_gap"] = (z["close"] - z["ema12"]) / (z["ema12"] + 1e-12)
    z = z.dropna().reset_index(drop=True)
    return z

def label_future(df: pd.DataFrame, horizon=1, thr_pos=0.0, thr_neg=0.0) -> np.ndarray:
    fut = df["close"].shift(-horizon) / df["close"] - 1.0
    y = np.where(fut > thr_pos, 1, np.where(fut < -thr_neg, -1, 0))
    return y

def backtest_one(symbol: str, tf: str, cfg: dict) -> dict:
    # Lataa data ja malli
    df = load_df(symbol, tf)
    feats_df = make_features(df)
    # Lataa v2-malli ja meta
    model_path = MODEL_DIR / f"pro_{symbol}_{tf}.joblib"
    meta_path  = MODEL_DIR / f"pro_{symbol}_{tf}.json"
    if not model_path.exists():
        raise FileNotFoundError(model_path)
    pipe = load(model_path)
    meta = json.loads(meta_path.read_text()) if meta_path.exists() else {}
    FEATS = meta.get("features") or ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

    # Valmistele data (drop viimeiset horizonin verran, ettei lookaheadia)
    horizon = int(cfg.get("train", {}).get("horizon_bars", 1))
    X = feats_df[FEATS].values
    prices = feats_df["close"].values
    n = len(prices)
    if n <= horizon + 5:
        raise RuntimeError(f"{symbol} {tf}: liian vähän dataa backtestiin")
    valid_n = n - horizon

    # Ennusteet (klassinen 3-luokka: -1/0/1). Jos clf antaa proba, käytetään sitä.
    try:
        y_pred = pipe.predict(X[:valid_n])
        proba = None
        if hasattr(pipe, "predict_proba"):
            try:
                proba = pipe.predict_proba(X[:valid_n])
            except Exception:
                proba = None
    except Exception as e:
        raise RuntimeError(f"Predict fail: {e}")

    # Tuottosarja: yksinkertainen long/short (0 = flat), ilman vipua
    # Ret_t = sign * (P_{t+h}/P_t - 1)
    fut = prices[horizon:valid_n+horizon] / prices[:valid_n] - 1.0
    sign = y_pred.astype(float)
    ret = sign * fut

    # Kauppakohtainen PnL (ketjutetaan position vaihtuessa/flatista)
    # Yksinkertaisesti: treidi alkaa kun sign != 0 ja päättyy kun sign vaihtuu tai palaa nollaan.
    trades = []
    cur_side = 0.0
    acc = 0.0
    for s, r in zip(sign, ret):
        if cur_side == 0.0 and s != 0.0:
            # uusi treidi alkaa
            cur_side = s
            acc = r
        elif cur_side != 0.0 and s == cur_side:
            # jatkuu samalla suunnalla
            acc += r
        elif cur_side != 0.0 and s != cur_side:
            # sulje vanha, aloita uusi/flat
            trades.append(acc)
            cur_side = s
            acc = 0.0 if s == 0.0 else r
        else:
            # pysyy flat
            pass
    if cur_side != 0.0:
        trades.append(acc)
    pnl_per_trade = np.array(trades, dtype=float)

    # Perusmetriikat
    total_pnl = float(100.0 * ret.sum())  # prosenttiyksikköinä (%)
    hr = hitrate(pnl_per_trade)
    dd = max_drawdown(equity_curve(ret, 1.0))
    pf = profit_factor(pnl_per_trade)
    # Sharpe: käytetään periodituottoja ret (esim. baarituotto) ja annualisointikerrointa tf:stä
    # 15m ~ 26*24*4=2496, 1h ~ 26*24=624, 4h ~ 26*6=156 (olettamus 26 pörssipäivää/kk * 12 kk?)
    tf_map = {"15m": 2496, "1h": 624, "4h": 156}
    periods = tf_map.get(tf, 252)
    sharpe = sharpe_ratio(ret, periods_per_year=periods)

    out = {
        "symbol": symbol,
        "tf": tf,
        "n_points": int(valid_n),
        "trades": int(len(pnl_per_trade)),
        "PnL": total_pnl,              # %
        "HitRate": hr,                 # %
        "MaxDD": dd,                   # %
        "ProfitFactor": pf,
        "Sharpe": sharpe,
    }

    # Tallenna raportti
    rep_path = REPORT_DIR / f"bt_{symbol}_{tf}.json"
    with open(rep_path, "w") as f:
        json.dump(out, f, indent=2)

    # Konsolituloste
    pf_str = "inf" if np.isinf(pf) else f"{pf:.2f}"
    print(f"[BT] {rep_path}  PnL={out['PnL']:.3f}%  HR={out['HitRate']:.2f}%  DD={out['MaxDD']:.2f}%  PF={pf_str}  Sharpe={out['Sharpe']:.2f}")
    return out

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="config.yaml")
    ap.add_argument("--symbols", nargs="*", default=None)
    ap.add_argument("--tfs", nargs="*", default=None)
    args = ap.parse_args()

    cfg = load_cfg(Path(args.config))
    symbols = args.symbols or (cfg.get("market", {}) or {}).get("symbols", [])
    if not symbols:
        symbols = (cfg.get("live", {}) or {}).get("symbols", [])
    if not symbols:
        raise SystemExit("Ei symboleita (--symbols tai config)")

    tfs = args.tfs or (cfg.get("train", {}) or {}).get("timeframes", ["15m","1h","4h"])

    for s in symbols:
        for tf in tfs:
            try:
                backtest_one(s, tf, cfg)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")

if __name__ == "__main__":
    main()
