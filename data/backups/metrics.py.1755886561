from __future__ import annotations
import numpy as np

def max_drawdown(equity: np.ndarray) -> float:
    """Palauttaa maksimi drawdownin prosentteina (0–100)."""
    eq = np.asarray(equity, dtype=float)
    peaks = np.maximum.accumulate(eq)
    dd = (eq - peaks) / peaks
    return float(-dd.min() * 100.0) if len(eq) else 0.0

def hitrate(pnl_per_trade: np.ndarray) -> float:
    """Voittavien treidien osuus (0–100)."""
    if len(pnl_per_trade) == 0:
        return 0.0
    wins = (pnl_per_trade > 0).sum()
    return float(100.0 * wins / len(pnl_per_trade))

def profit_factor(pnl_per_trade: np.ndarray) -> float:
    """Gross Profit / Gross Loss. Jos ei tappioita, palauttaa inf."""
    if len(pnl_per_trade) == 0:
        return 0.0
    gp = pnl_per_trade[pnl_per_trade > 0].sum()
    gl = -pnl_per_trade[pnl_per_trade < 0].sum()
    return float(np.inf) if gl == 0 else float(gp / gl)

def sharpe_ratio(ret_series: np.ndarray, periods_per_year: int = 252) -> float:
    """
    Sharpe = mean / std * sqrt(annualize). ret_series on sarja periodituottoja (esim. treidin tai baarin %/100).
    Jos std=0, palauttaa 0.
    """
    r = np.asarray(ret_series, dtype=float)
    if len(r) == 0:
        return 0.0
    mu = r.mean()
    sd = r.std(ddof=1) if len(r) > 1 else 0.0
    if sd == 0:
        return 0.0
    return float((mu / sd) * np.sqrt(periods_per_year))

def equity_curve(ret_series: np.ndarray, start_equity: float = 1.0) -> np.ndarray:
    """Kertyytyvä pääoma ret_series:stä (1+ret)."""
    r = np.asarray(ret_series, dtype=float)
    eq = [start_equity]
    for x in r:
        eq.append(eq[-1] * (1.0 + x))
    return np.asarray(eq[1:], dtype=float)
