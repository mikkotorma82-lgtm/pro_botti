#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
live_daemon.py — Live-traderi

Integraatiot:
 - AI-gate: tools.ai_gate._gd_call_and_exec(lukee models/pro_{SYMBOL}_{TF}.json -> ai_thresholds)
 - Position sizer: tools.position_sizer.calc_order_size (riskipohjainen, broker-minimit/step/leverage)
 - Capital API: tools.capital_client.CapitalClient (tilin vapaa pääoma, hinnat, toimeksiannot)

Ympäristömuuttujat (systemd-palvelussa):
  SYMBOLS=BTCUSDT,ETHUSDT,...        # pilkulla eroteltu lista
  TFS=15m,1h,4h                      # pilkulla eroteltu lista
  LOOP_SEC=30                        # loopin viive sekunteina
  RISK_PCT=0.10                      # perusriskiprosentti (override mahdollinen risk_overrides.json)
  RISK_SAFETY=0.95                   # turvakerroin riskibudjetille
  DRY_RUN=0                          # 1=älä tee toimeksiantoja, logita vain
  AIGATE_TG=0                        # 1=lähetä päätöslokit TG:hen tools.tele:n kautta

Huom:
 - Jos signaalimoduuli (tools.trade_live) ei ole saatavilla tai ei palauta p_up-todennäköisyyttä,
   daemon ei avaa treidiä (HOLD). Tämä on tarkoituksella turvallista.
"""

import os
import sys
import time
import traceback
from datetime import datetime, timezone
from typing import Optional, Dict, Any, Tuple, List

# ----- Sisäiset työkalut -----
try:
    from tools.tele import send as tgsend
except Exception:
    def tgsend(msg: str):  # no-op jos TG ei ole konffattu
        pass

from tools.ai_gate import gate_decision
from tools.position_sizer import calc_order_size
try:
    from tools.instrument_loader import load_instruments
except Exception:
    # Fallback: kerää instrumentit models/pro_*.json -tiedostoista
    def load_instruments():
        import json, glob, os
        models_dir = os.path.join(os.path.dirname(__file__), "..", "models")
        paths = glob.glob(os.path.join(models_dir, "pro_*_*.json"))
        out = []
        for path in paths:
            try:
                with open(path) as f:
                    meta = json.load(f)
                sym = meta.get("symbol")
                tf  = meta.get("tf") or meta.get("timeframe") or meta.get("tf_str")
                if sym and tf:
                    # Palautetaan listana dicttejä: {"symbol": "...", "tf": "..."}
                    out.append({"symbol": sym, "tf": tf})
            except Exception:
                pass
        # Poista duplikaatit (symbol, tf)
        seen = set()
        uniq = []
        for d in out:
            k = (d["symbol"], d["tf"])
            if k in seen:
                continue
            seen.add(k); uniq.append(d)
        return uniq


# Capital API -asiakas (sallitaan puuttua -> dry mode)
try:
    from tools.capital_client import CapitalClient
except Exception:
    CapitalClient = None  # type: ignore

ROOT = "/root/pro_botti"


# --------- Pienet apurit ---------
def now_iso() -> str:
    return datetime.now(timezone.utc).isoformat()

def log(line: str) -> None:
    try:
        print(line, flush=True)
    except Exception:
        pass

def env_csv(name: str, default: str) -> List[str]:
    raw = os.getenv(name, default)
    return [x.strip() for x in raw.split(",") if x.strip()]

def safe_float(x, default: float = 0.0) -> float:
    try:
        return float(x)
    except Exception:
        return default


# --------- Capital-asiakas & tiedot ---------

class Broker:
    def __init__(self):
        self.cli = None
        self.logged_in = False
        self._last_free = 0.0

        # CapitalClient voi puuttua — tällöin DRY
        try:
            from tools.capital_client import CapitalClient as _Cap  # lazy import
        except Exception:
            log("[WARN] CapitalClient ei saatavilla -> DRY mode")
            self.cli = None
            self.logged_in = False
            return

        # Luo clientti; jos onnistuu, kirjataan sisään (clientin oma login tai REST-tokenit)
        try:
            self.cli = _Cap()
            # jos live_daemonissa on _capital_login, käytä sitä
            try:
                from tools import live_daemon as _ld
                if hasattr(_ld, "_capital_login"):
                    self.logged_in = bool(_ld._capital_login(self.cli))
                else:
                    # fallback: jos clientissa on login-metodi
                    if hasattr(self.cli, "login"):
                        self.cli.login()
                        self.logged_in = True
                    else:
                        self.logged_in = True
            except Exception:
                # yritä clientin loginia, jos löytyy
                if hasattr(self.cli, "login"):
                    self.cli.login()
                    self.logged_in = True
                else:
                    self.logged_in = True
            log("[INFO] Capital login ok")
        except Exception as e:
            log(f"[WARN] Capital login epäonnistui -> DRY mode ({e})")
            self.cli = None
            self.logged_in = False

    def free_balance(self) -> float:
        """Hae tilin vapaa pääoma (available)."""
        if not self.logged_in or self.cli is None:
            return self._last_free
        try:
            acc = self.cli.account_info()
            free = 0.0
            if isinstance(acc, dict) and "accounts" in acc:
                for a in acc["accounts"]:
                    if a.get("preferred") or a.get("status") == "ENABLED":
                        free = safe_float(a.get("balance", {}).get("available", 0.0))
                        break
            self._last_free = max(0.0, free)
        except Exception as e:
            log(f"[WARN] account_info epäonnistui: {e}")
        return self._last_free

    def _rest_last_price(self, symbol: str):

        """Capital REST: /api/v1/prices/{EPIC}?resolution=MINUTE&max=1 (VERSION=3).
Mapittaa USDT->USD ennen EPIC-resoluutiota ja parsii closePrice.bid/ask → mid.
Palauttaa float tai None.
"""

        if self.cli is None or not hasattr(self.cli, "session"):

            return None

        import os

        base = getattr(self.cli, "base", None) or os.getenv("CAPITAL_API_BASE")

        if not base:

            return None

        # symbolin mapitus (USDT -> USD)

        try:

            sym = map_symbol_for_capital(symbol)

        except Exception:

            sym = (symbol or "").upper()

        # EPIC-resoluutio (env override sallittu)

        try:

            epic = _capital_resolve_epic(self.cli, sym)

        except Exception:

            epic = sym

        sess = self.cli.session

        hdr  = dict(getattr(sess, "headers", {}))

        hdr.setdefault("Accept", "application/json")

        hdr.setdefault("Content-Type", "application/json")

        hdr["VERSION"] = "3"

        url = f"{base.rstrip('/')}/api/v1/prices/{epic}?resolution=MINUTE&max=1"

        try:

            r = sess.get(url, headers=hdr, timeout=10)

            r.raise_for_status()

            js = r.json() or {}

            arr = js.get("prices") or js.get("content") or []

            if not arr:

                return None

            p = arr[-1]

            # closePrice/openPrice/highPrice/lowPrice voivat olla muotoa {'bid': x, 'ask': y}

            def mid_from(d):

                if isinstance(d, dict):

                    bid = d.get("bid"); ask = d.get("ask")

                    if isinstance(bid,(int,float)) and isinstance(ask,(int,float)):

                        return (bid+ask)/2.0

                return None

            for key in ("closePrice","openPrice","highPrice","lowPrice"):

                v = p.get(key)

                m = mid_from(v)

                if isinstance(m,(int,float)):

                    return float(m)

            # joskus bid/ask voi olla suoraan juuritasolla

            bid = p.get("bid"); ask = p.get("ask")

            if isinstance(bid,(int,float)) and isinstance(ask,(int,float)):

                return (bid+ask)/2.0

            return None

        except Exception as e:

            # ei kaadeta daemonia: logitus hoituu ylemmällä tasolla

            return None

    def place_order(self, side: str, symbol: str, size: float, meta: Dict[str, Any]) -> bool:
        """Lähetä markkinatoimeksianto (best effort). Palauttaa True jos 'onnistui'."""
        dry = os.getenv("DRY_RUN", "0") == "1"
        if dry or not self.logged_in or self.cli is None:
            log(f"[TRADE] DRY side={side} symbol={symbol} size={size} notional≈{meta.get('notional'):.4f}")
            return True

        try:
            if hasattr(self.cli, "place_market"):
                self.cli.place_market(symbol=symbol, side=side, size=size)
            elif hasattr(self.cli, "place_order"):
                self.cli.place_order(symbol=symbol, side=side, size=size, order_type="MARKET")
            else:
                log("[ERROR] CapitalClient ei tunne place_market/place_order – skip")
                return False

            log(f"[TRADE] LIVE side={side} symbol={symbol} size={size}")
            return True
        except Exception as e:
            log(f"[ERROR] Order epäonnistui: side={side} symbol={symbol} size={size} err={e}")
            return False




    def place_order(self, side: str, symbol: str, size: float, meta: Dict[str, Any]) -> bool:
        """Lähetä markkinatoimeksianto (best effort). Palauttaa True jos 'onnistui'."""
        dry = os.getenv("DRY_RUN", "0") == "1"
        if dry or not self.logged_in or self.cli is None:
            log(f"[TRADE] DRY side={side} symbol={symbol} size={size} notional≈{meta.get('notional'):.4f}")
            return True

        try:
            if hasattr(self.cli, "place_market"):
                self.cli.place_market(symbol=symbol, side=side, size=size)
            elif hasattr(self.cli, "place_order"):
                self.cli.place_order(symbol=symbol, side=side, size=size, order_type="MARKET")
            else:
                log("[ERROR] CapitalClient ei tunne place_market/place_order – skip")
                return False

            log(f"[TRADE] LIVE side={side} symbol={symbol} size={size}")
            return True
        except Exception as e:
            log(f"[ERROR] Order epäonnistui: side={side} symbol={symbol} size={size} err={e}")
            return False



def map_symbol_for_capital(sym: str) -> str:
    sym = (sym or "").upper()
    return sym[:-4] + "USD" if sym.endswith("USDT") else sym


def _capital_resolve_epic(cli, symbol: str) -> str:
    """Palauta EPIC. Oletus: EPIC == symbol (esim. BTCUSD).
    Yliaja env: CAPITAL_EPIC_<SYMBOL> (esim. CAPITAL_EPIC_BTCUSD=BTCUSD)"""
    import os
    key = f"CAPITAL_EPIC_{symbol.upper()}"
    return os.getenv(key, symbol)

def map_symbol_for_capital(sym: str) -> str:
    sym = (sym or "").upper()
    return sym[:-4] + "USD" if sym.endswith("USDT") else sym

def _capital_resolve_epic(cli, symbol: str) -> str:
    """Palauta EPIC Capitalille. Oletus: EPIC == symbol (esim. BTCUSD).
    Yliaja env: CAPITAL_EPIC_<SYMBOL> (esim. CAPITAL_EPIC_BTCUSD=BTCUSD)."""
    import os
    key = f"CAPITAL_EPIC_{(symbol or '').upper()}"
    return os.getenv(key, symbol)

def map_symbol_for_capital(sym: str) -> str:
    sym = (sym or "").upper()
    return sym[:-4] + "USD" if sym.endswith("USDT") else sym

def _capital_resolve_epic(cli, symbol: str) -> str:
    """Palauta EPIC Capitalille. Oletus: EPIC == symbol (esim. BTCUSD).
    Yliaja env: CAPITAL_EPIC_<SYMBOL> (esim. CAPITAL_EPIC_BTCUSD=BTCUSD)."""
    import os
    key = f"CAPITAL_EPIC_{(symbol or '').upper()}"
    return os.getenv(key, symbol)


def _cap_get(cli, url, version: int, timeout=10):
    sess = cli.session
    hdr = dict(sess.headers)
    hdr.setdefault("Accept","application/json")
    hdr.setdefault("Content-Type","application/json")
    hdr["VERSION"] = str(version)
    r = sess.get(url, headers=hdr, timeout=timeout)
    r.raise_for_status()
    return r


def _broker_last_price(self, symbol: str) -> float:
    """Palauta viimeisin hinta Capitalista.
    Järjestys:
      1) yritä CapitalClient.* last price -metodeja
      2) REST /api/v1/prices/{EPIC}?resolution=MINUTE&max=1 (VERSION=3)
      3) ENV-välimuisti LASTPX_<SYMBOL>
    """
    import os

    # apu: num/dict mid
    def _mid(v):
        if isinstance(v, dict):
            b, a = v.get("bid"), v.get("ask")
            if isinstance(b, (int, float)) and isinstance(a, (int, float)):
                return (b + a) / 2.0
        if isinstance(v, (int, float)):
            return float(v)
        return None

    raw = (symbol or "").upper()
    sym = map_symbol_for_capital(raw) if 'map_symbol_for_capital' in globals() else raw

    # 1) client-metodit
    if getattr(self, "cli", None) is not None:
        for nm in ("last_price","price","quote","get_price","get_last_price"):
            fn = getattr(self.cli, nm, None)
            if callable(fn):
                try:
                    val = fn(sym)
                    px = None
                    if isinstance(val, (int, float)):
                        px = float(val)
                    elif isinstance(val, dict):
                        px = (
                            _mid(val.get("mid"))
                            or _mid(val.get("price"))
                            or _mid(val.get("last"))
                            or _mid(val.get("close"))
                            or _mid(val)
                        )
                    elif isinstance(val, (list, tuple)) and val:
                        px = _mid(val[-1])
                    if isinstance(px, (int, float)):
                        os.environ[f"LASTPX_{sym}"] = str(px)
                        return float(px)
                except Exception:
                    pass

    # 2) REST /prices (VERSION=3)
    try:
        base = getattr(self.cli, "base", None) or os.getenv("CAPITAL_API_BASE")
        sess = getattr(self.cli, "session", None)
        if base and sess:
            try:
                epic = _capital_resolve_epic(self.cli, sym)  # env-override jos määritelty
            except Exception:
                epic = sym
            url = f"{base.rstrip('/')}/api/v1/prices/{epic}?resolution=MINUTE&max=1"
            # käytä _cap_get jos olemassa (asettaa VERSION-headerin oikein)
            if '_cap_get' in globals():
                r = _cap_get(self.cli, url, 3, timeout=10)
            else:
                hdr = dict(getattr(sess, "headers", {}))
                hdr.setdefault("Accept", "application/json")
                hdr.setdefault("Content-Type", "application/json")
                hdr["VERSION"] = "3"
                r = sess.get(url, headers=hdr, timeout=10)
                r.raise_for_status()

            js = r.json() or {}
            arr = js.get("prices") or js.get("content") or []
            if arr:
                p = arr[-1]
                # closePrice.bid/ask -> mid (paras reaali-läheinen)
                cp = p.get("closePrice") or {}
                bid, ask = cp.get("bid"), cp.get("ask")
                mid = _mid({"bid": bid, "ask": ask})
                if isinstance(mid, (int, float)):
                    os.environ[f"LASTPX_{sym}"] = str(mid)
                    return float(mid)
                # fallback muihin
                op = p.get("openPrice") or {}
                mid2 = _mid(op) or _mid(cp) or _mid(p.get("highPrice") or {}) or _mid(p.get("lowPrice") or {})
                if isinstance(mid2, (int, float)):
                    os.environ[f"LASTPX_{sym}"] = str(mid2)
                    return float(mid2)
    except Exception:
        pass

    # 3) ENV-fallback
    try:
        return float(os.getenv(f"LASTPX_{sym}", "0") or 0)
    except Exception:
        return 0.0

# Sido luokan metodiksi vain jos puuttuu
try:
    Broker  # varmista että luokka on olemassa
    if not hasattr(Broker, "last_price"):
        setattr(Broker, "last_price", _broker_last_price)
except Exception:
    pass

def _cap_price_mid(cli, raw_symbol: str):
    import os
    base = getattr(cli, "base", None) or os.getenv("CAPITAL_API_BASE")
    if not base: 
        return None
    sym  = map_symbol_for_capital(raw_symbol)  # BTCUSDT -> BTCUSD
    epic = _capital_resolve_epic(cli, sym)
    url  = f"{base.rstrip('/')}/api/v1/prices/{epic}?resolution=MINUTE&max=1"
    try:
        r   = _cap_get(cli, url, 3)
        js  = r.json() or {}
        arr = js.get("prices") or js.get("content") or []
        if not arr: 
            return None
        last = arr[-1]
        cp   = last.get("closePrice") or {}
        bid, ask = cp.get("bid"), cp.get("ask")
        if isinstance(bid,(int,float)) and isinstance(ask,(int,float)):
            return (bid+ask)/2.0
        # fallbackeja jos closePrice puuttuu
        for k in ("openPrice","highPrice","lowPrice"):
            p = last.get(k) or {}
            b,a = p.get("bid"), p.get("ask")
            if isinstance(b,(int,float)) and isinstance(a,(int,float)):
                return (b+a)/2.0
    except Exception:
        pass
    return None

def _get_last_price_force(broker, symbol: str):
    # 1) Broker.last_price jos on
    try:
        px = None
        if hasattr(broker, "last_price"):
            px = _get_last_price_force(broker, symbol)
        if isinstance(px,(int,float)) and px>0:
            return float(px)
    except Exception:
        pass
    # 2) Broker.cli.* last_price variantit
    cli = getattr(broker, "cli", None)
    if cli:
        for nm in ("last_price","get_price","price","quote","get_last","get_last_price"):
            fn = getattr(cli, nm, None)
            if callable(fn):
                try:
                    v = fn(map_symbol_for_capital(symbol))
                    if isinstance(v,(int,float)) and v>0:
                        return float(v)
                    if isinstance(v, dict):
                        # dict -> mid tai price/last/close
                        if "mid" in v and isinstance(v["mid"], (int,float)):
                            return float(v["mid"])
                        for k in ("price","last","close"):
                            if isinstance(v.get(k), (int,float)):
                                return float(v[k])
                        b = v.get("bid"); a = v.get("ask")
                        if isinstance(b,(int,float)) and isinstance(a,(int,float)):
                            return (b+a)/2.0
                except Exception:
                    pass
        # 3) Pakota REST-mid
        try:
            mid = _cap_price_mid(cli, symbol)
            if isinstance(mid,(int,float)) and mid>0:
                return float(mid)
        except Exception:
            pass
    # 4) ENV-välimuisti
    import os
    sym_map = map_symbol_for_capital(symbol)
    ev = os.getenv(f"LASTPX_{sym_map}") or os.getenv(f"LASTPX_{symbol}")
    try:
        if ev is not None:
            v = float(ev)
            if v>0: 
                return v
    except Exception:
        pass
    return None

# --- Injected wrapper: extend Broker.last_price with REST fallback (idempotent) ---
try:
    if not getattr(Broker, "_wrapped_last_price", False):
        _orig_last_price = Broker.last_price
        def _last_price_wrapped(self, symbol: str) -> float:
            # 1) Yritä alkuperäistä toteutusta
            try:
                v = _orig_last_price(self, symbol)
                if v and float(v) != 0.0:
                    return float(v)
            except Exception:
                pass
            # 2) Map USDT->USD ja REST /prices → mid
            try:
                sym = map_symbol_for_capital(symbol)
                v2 = _get_last_price_force(self, sym)
                if v2 and float(v2) != 0.0:
                    return float(v2)
            except Exception:
                pass
            # 3) ENV-välimuisti LASTPX_<SYMBOL>
            try:
                import os
                sym = map_symbol_for_capital(symbol)
                envv = os.getenv(f"LASTPX_{sym}")
                if envv:
                    return float(envv)
            except Exception:
                pass
            return 0.0
        Broker.last_price = _last_price_wrapped
        Broker._wrapped_last_price = True
except Exception:
    pass

def _cap_get_rest_session(broker):
    """Palauta (tai luo) Capitalin REST-sessio, jossa on CST ja X-SECURITY-TOKEN.
    Käyttää aliaksia: CAPITAL_API_KEY|CAPITAL_KEY, CAPITAL_USERNAME|CAPITAL_LOGIN|CAPITAL_EMAIL, CAPITAL_PASSWORD.
    """
    import os, requests
    # cache brokkeriin
    sess = getattr(broker, "_rest_sess", None)
    base = os.getenv("CAPITAL_API_BASE", "").rstrip("/")
    key  = os.getenv("CAPITAL_API_KEY") or os.getenv("CAPITAL_KEY")
    usr  = os.getenv("CAPITAL_USERNAME") or os.getenv("CAPITAL_LOGIN") or os.getenv("CAPITAL_EMAIL")
    pwd  = os.getenv("CAPITAL_PASSWORD")
    if sess and getattr(sess, "_cap_ok", False):
        return sess, base
    if not (base and key and usr and pwd):
        return None, base
    sess = requests.Session()
    # login
    h = {"X-CAP-API-KEY": key, "Content-Type": "application/json", "Accept": "application/json", "VERSION": "2"}
    r = sess.post(f"{base}/api/v1/session", headers=h, json={"identifier": usr, "password": pwd}, timeout=15)
    r.raise_for_status()
    # headerit tulevat response-headerista
    cst = r.headers.get("CST"); sec = r.headers.get("X-SECURITY-TOKEN")
    if not (cst and sec):
        # jotkut ympäristöt palauttavat ne bodyssa -> kokeillaan
        try:
            js = r.json() or {}
            cst = cst or js.get("CST") or js.get("cst")
            sec = sec or js.get("X-SECURITY-TOKEN") or js.get("x-security-token")
        except Exception:
            pass
    if not (cst and sec):
        raise RuntimeError("Capital REST login ok mutta CST/X-SECURITY-TOKEN puuttuu")
    sess.headers.update({"CST": cst, "X-SECURITY-TOKEN": sec, "X-CAP-API-KEY": key})
    sess._cap_ok = True
    broker._rest_sess = sess
    return sess, base

def _cap_rest_last_mid(broker, epic: str):
    import json
    sess, base = _cap_get_rest_session(broker)
    if not (sess and base and epic):
        return None
    url = f"{base}/api/v1/prices/{epic}?resolution=MINUTE&max=1"
    h = dict(sess.headers); h["VERSION"] = "3"; h.setdefault("Accept","application/json")
    r = sess.get(url, headers=h, timeout=10)
    r.raise_for_status()
    js = r.json() or {}
    arr = js.get("prices") or js.get("content") or []
    if not arr:
        return None
    p = arr[-1]
    cb = ((p.get("closePrice") or {}).get("bid")); ca = ((p.get("closePrice") or {}).get("ask"))
    if isinstance(cb,(int,float)) and isinstance(ca,(int,float)):
        return (cb+ca)/2.0
    ob = ((p.get("openPrice") or {}).get("bid")); oa = ((p.get("openPrice") or {}).get("ask"))
    if isinstance(ob,(int,float)) and isinstance(oa,(int,float)):
        return (ob+oa)/2.0
    return None

def capital_ensure_tokens(cli) -> bool:
    """
    Varmistaa että CLI:ssä on CST ja X-SECURITY-TOKEN.
    Palauttaa True kun tokenit ovat olemassa (onnistui tai jo valmiina).
    """
    try:
        sess = getattr(cli, "session", None)
        base = getattr(cli, "base", None)
        if not sess or not base:
            return False
        if sess.headers.get("CST") and sess.headers.get("X-SECURITY-TOKEN"):
            return True
        # koita REST-loginia jos funktio on olemassa
        if "_capital_rest_login" in globals():
            try:
                ok = _capital_rest_login(cli)
                return bool(ok and sess.headers.get("CST") and sess.headers.get("X-SECURITY-TOKEN"))
            except Exception:
                return False
        return False
    except Exception:
        return False

def capital_rest_login_force(cli) -> bool:
    """
    Luo REST-sessio Capital.comiin ja aseta tokenit sessioon:
      - headers['CST']
      - headers['X-SECURITY-TOKEN']
      - headers['X-CAP-API-KEY']
    Palauttaa True jos molemmat (CST & X-SECURITY-TOKEN) ovat asetettu.
    """
    try:
        import os
        sess = getattr(cli, "session", None)
        base = (getattr(cli, "base", None) or os.getenv("CAPITAL_API_BASE") or "").rstrip("/")
        key  = os.getenv("CAPITAL_API_KEY") or os.getenv("CAPITAL_KEY")
        usr  = os.getenv("CAPITAL_USERNAME") or os.getenv("CAPITAL_LOGIN") or os.getenv("CAPITAL_EMAIL")
        pwd  = os.getenv("CAPITAL_PASSWORD")
        if not (sess and base and key and usr and pwd):
            return False

        url = f"{base}/api/v1/session"
        hdr = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "X-CAP-API-KEY": key,
        }
        payload = {"identifier": usr, "password": pwd}

        r = sess.post(url, headers=hdr, json=payload, timeout=15)
        r.raise_for_status()

        # tokenit voivat tulla otsikoissa; pidetään molemmat mahdolliset avaimet
        cst = r.headers.get("CST")
        xst = r.headers.get("X-SECURITY-TOKEN") or r.headers.get("X_SECURITY_TOKEN")

        if not (cst and xst):
            # joskus bodyllä tulee meta – yritetään vielä varovasti
            try:
                js = r.json() or {}
                cst = cst or js.get("CST") or js.get("cst")
                xst = xst or js.get("X-SECURITY-TOKEN") or js.get("xSecurityToken")
            except Exception:
                pass

        if not (cst and xst):
            return False

        sess.headers["CST"] = cst
        sess.headers["X-SECURITY-TOKEN"] = xst
        sess.headers["X-CAP-API-KEY"] = key
        # yleishyvä oletus
        sess.headers.setdefault("Accept", "application/json")
        sess.headers.setdefault("Content-Type", "application/json")
        return True
    except Exception:
        return False

def _capital_rest_login(cli) -> bool:
    """
    Pakotettu REST-login Capital.comiin:
      POST {base}/api/v1/session
      headers: X-CAP-API-KEY
      body: {"identifier": USER, "password": PASS}
    Asettaa sessioon: CST, X-SECURITY-TOKEN, X-CAP-API-KEY
    """
    try:
        import os
        sess = getattr(cli, "session", None)
        base = (getattr(cli, "base", None) or os.getenv("CAPITAL_API_BASE") or "").rstrip("/")
        key  = os.getenv("CAPITAL_API_KEY") or os.getenv("CAPITAL_KEY")
        usr  = os.getenv("CAPITAL_USERNAME") or os.getenv("CAPITAL_LOGIN") or os.getenv("CAPITAL_EMAIL")
        pwd  = os.getenv("CAPITAL_PASSWORD")
        if not (sess and base and key and usr and pwd):
            return False

        url = f"{base}/api/v1/session"
        hdr = {
            "Accept": "application/json",
            "Content-Type": "application/json",
            "X-CAP-API-KEY": key,
        }
        payload = {"identifier": usr, "password": pwd}
        r = sess.post(url, headers=hdr, json=payload, timeout=20)
        r.raise_for_status()

        # tokenit ovat vasteen otsikoissa
        cst = r.headers.get("CST")
        xst = r.headers.get("X-SECURITY-TOKEN") or r.headers.get("X_SECURITY_TOKEN")

        # fallback: joskus body sisältää avaimet
        if not (cst and xst):
            try:
                js = r.json() or {}
                cst = cst or js.get("CST") or js.get("cst")
                xst = xst or js.get("X-SECURITY-TOKEN") or js.get("xSecurityToken")
            except Exception:
                pass

        if not (cst and xst):
            return False

        sess.headers["CST"] = cst
        sess.headers["X-SECURITY-TOKEN"] = xst
        sess.headers["X-CAP-API-KEY"] = key
        sess.headers.setdefault("Accept", "application/json")
        sess.headers.setdefault("Content-Type", "application/json")
        return True
    except Exception:
        return False

def capital_ensure_tokens(cli) -> bool:
    """
    Varmistaa että sessiossa on CST & X-SECURITY-TOKEN.
    """
    try:
        sess = getattr(cli, "session", None)
        base = getattr(cli, "base", None)
        if not sess or not base:
            return False
        if sess.headers.get("CST") and sess.headers.get("X-SECURITY-TOKEN"):
            return True

        # 1) Jos CapitalClientilta löytyy login/authenticate tms., kokeile
        for nm in ("login","authenticate","signin","create_session","start","login_session"):
            fn = getattr(cli, nm, None)
            if callable(fn):
                try:
                    fn()
                except Exception:
                    pass
                if sess.headers.get("CST") and sess.headers.get("X-SECURITY-TOKEN"):
                    return True

        # 2) Meidän REST-login
        return _capital_rest_login(cli)
    except Exception:
        return False

def get_bid_ask(broker, symbol: str):
    """
    Palauta (bid, ask) Capital RESTistä /api/v1/prices/{EPIC}?resolution=MINUTE&max=1 (VERSION=3).
    """
    try:
        cli = getattr(broker, "cli", None)
        if not cli or not getattr(cli, "session", None):
            return (None, None)

        base = (getattr(cli, "base", None) or "").rstrip("/")
        if not base:
            return (None, None)

        # varmista tokenit
        if not capital_ensure_tokens(cli):
            return (None, None)

        sess = cli.session
        hdr = dict(getattr(sess, "headers", {}))
        hdr.setdefault("Accept", "application/json")
        hdr.setdefault("Content-Type", "application/json")
        hdr["VERSION"] = "3"

        # EPIC-resoluutio
        epic = symbol
        try:
            if "map_symbol_for_capital" in globals():
                epic = map_symbol_for_capital(epic)  # BTCUSDT -> BTCUSD
            if "_capital_resolve_epic" in globals():
                epic = _capital_resolve_epic(cli, epic)  # sallii env-yliasetuksen
        except Exception:
            pass

        url = f"{base}/api/v1/prices/{epic}?resolution=MINUTE&max=1"
        if "_cap_get" in globals():
            r = _cap_get(cli, url, 3)
        else:
            r = sess.get(url, headers=hdr, timeout=10)
            r.raise_for_status()

        js  = r.json() or {}
        arr = js.get("prices") or js.get("content") or []
        if not arr:
            return (None, None)
        p = arr[-1]
        # ensisijaisesti closePrice → jos puuttuu, käytä openPrice
        cp = p.get("closePrice") or {}
        bid = cp.get("bid"); ask = cp.get("ask")
        if (bid is None or ask is None) and isinstance(p.get("openPrice"), dict):
            op = p["openPrice"]
            bid = bid if bid is not None else op.get("bid")
            ask = ask if ask is not None else op.get("ask")

        try: bid = float(bid)
        except Exception: bid = None
        try: ask = float(ask)
        except Exception: ask = None
        if bid is None or ask is None:
            return (None, None)
        return (bid, ask)
    except Exception:
        return (None, None)

def _pick_exec_price(side: str, bid: float, ask: float) -> float:
    side = (side or "").upper()
    if side == "BUY":
        return float(ask)
    if side == "SELL":
        return float(bid)
    # oletus: konservatiivinen
    return float((bid + ask) / 2.0)

def trade_loop():
    """
    Yksinkertainen päätössilmukka:
      - Broker & token-varmistus (capital_ensure_tokens)
      - SYMBOLS x TFS iterointi
      - bid/ask haku Capitalista + spread-vartija (SPREAD_MAX_PCT, oletus 0.4%)
      - gate_decision-kutsu (tuottaa [AIGATE]-logit)
    """
    import os, time, traceback
    LOOP_SEC = int(os.getenv("LOOP_SEC", "30"))
    SPREAD_MAX_PCT = float(os.getenv("SPREAD_MAX_PCT", "0.004"))

    from tools import live_daemon as ld
    log = getattr(ld, "log", print)

    log("[LOOP] trade_loop start")
    while True:
        try:
            # Broker + mahdolliset Capital-tokenit
            b = ld.Broker()
            cli = getattr(b, "cli", None)
            if cli is not None and hasattr(ld, "capital_ensure_tokens"):
                ld.capital_ensure_tokens(cli)

            # Aja kaikki symbolit ja timeframe:t
            symbols = os.getenv("SYMBOLS", "BTCUSDT,ETHUSDT,ADAUSDT,SOLUSDT,XRPUSDT")
            tfs = os.getenv("TFS", "15m,1h,4h")
            syms = [x.strip() for x in symbols.split(",") if x.strip()]
            tf_list = [x.strip() for x in tfs.split(",") if x.strip()]

            for symbol in syms:
                try:
                    symbol_cap = ld.map_symbol_for_capital(symbol)
                    bid, ask = ld.get_bid_ask(b, symbol_cap)
                    if bid is None or ask is None:
                        log(f"[PRICE] {symbol} -> {symbol_cap} (no bid/ask)")
                        continue

                    mid = (bid + ask) / 2.0
                    spread = (ask - bid) / mid if mid else 1e9
                    if spread > SPREAD_MAX_PCT:
                        log(f"[PRICE] {symbol} spread {spread*100:.3f}% > {SPREAD_MAX_PCT*100:.2f}% -> skip")
                        continue

                    log(f"[PRICE] {symbol} -> {symbol_cap} bid={bid} ask={ask} spread={spread*100:.3f}%")

                    for tf in tf_list:
                        try:
                            ld._gd_call_and_exec(symbol, tf)
                        except Exception as e:
                            log(f"[AIGATE-ERR] {symbol} {tf}: {e}")
                except Exception as e:
                    log(f"[ERR] symbol loop {symbol}: {e}")

            time.sleep(LOOP_SEC)

        except KeyboardInterrupt:
            raise
        except Exception as e:
            log(f"[LOOP-ERR] {e}")
            traceback.print_exc()
            time.sleep(LOOP_SEC)


if __name__ == "__main__":
    import os, time, traceback, types
    try:
        LOOP_SEC = int(os.getenv("LOOP_SEC", "30"))
    except Exception:
        LOOP_SEC = 30

    print("[BOOT] live_daemon starting")
    entry = os.getenv("ENTRY_FN") or os.getenv("MAIN_FN")
    candidates = ("main","run_loop","run","trade_loop","loop","start","daemon","live","run_once","step")
    print(f"[BOOT] ENTRY_FN={entry!r} | candidates={candidates}")

    funcs = sorted([k for k,v in globals().items() if isinstance(v, types.FunctionType)])
    print(f"[BOOT] functions_in_globals={funcs}")

    fn = None
    if entry:
        fn = globals().get(entry)
    if not fn:
        for name in candidates:
            fn = globals().get(name)
            if callable(fn):
                entry = name
                break

    if callable(fn):
        print(f"[BOOT] Entry function resolved -> {entry}(); running…")
        try:
            fn()
        except KeyboardInterrupt:
            pass
        except Exception as e:
            print(f"[BOOT-ERR] {e}")
            traceback.print_exc()
            time.sleep(LOOP_SEC)
    else:
        print("[BOOT] No entry function found; idling")
        while True:
            time.sleep(LOOP_SEC)

# --- ORDER EXECUTION GLUE ----------------------------------------------------
def _envf(name, default):
    import os
    try:
        v = os.getenv(name)
        return float(v) if v not in (None, "") else float(default)
    except Exception:
        return float(default)

def _envi(name, default):
    import os
    try:
        v = os.getenv(name)
        return int(v) if v not in (None, "") else int(default)
    except Exception:
        return int(default)

def _envb(name, default=False):
    import os
    v = str(os.getenv(name, str(int(default)))).strip().lower()
    return v in ("1","true","yes","on")

def on_signal(symbol, side, tf, bid, ask):
    """
    Kutsutaan kun gate_decision antaa selkeän LONG/SHORT signaalin.
    side: 'BUY' tai 'SELL'
    """
    import os, math, time
    spread = (ask-bid)/((ask+bid)/2.0)
    spread_max = _envf("SPREAD_MAX_PCT", 0.004)
    if spread > spread_max:
        log(f"[ORDER] {symbol} skip: spread {spread:.3%} > {spread_max:.3%}")
        return

    # Riskinhallinta ja position koko
    balance = _envf("ACCOUNT_BALANCE_USD", 10000.0)
    risk_pct = _envf("RISK_PER_TRADE", 0.0075)
    stop_pct = _envf("STOP_LOSS_PCT", 0.005)
    risk_usd = balance * risk_pct
    price = ask if side == "BUY" else bid
    notional = risk_usd / stop_pct
    qty = notional / price

    tp_rr = _envf("TAKE_PROFIT_RR", 2.0)
    if side == "BUY":
        sl = price * (1 - stop_pct)
        tp = price * (1 + stop_pct * tp_rr)
    else:
        sl = price * (1 + stop_pct)
        tp = price * (1 - stop_pct * tp_rr)

    # Toteutus: kuiva-ajo vai oikea toimeksianto
    if not _envb("EXECUTE_ORDERS", False) or _envb("DRY_RUN", False) or not _envb("ENABLE", True):
        log(f"[ORDER][DRY] {side} {symbol} qty≈{qty:.6f} @~{price:.4f} SL~{sl:.4f} TP~{tp:.4f} tf={tf}")
        return

    try:
        # TODO: Lisää Capital REST order -kutsu tänne (place_market_order_capital)
        log(f"[ORDER] {side} {symbol} qty≈{qty:.6f} @~{price:.4f} SL~{sl:.4f} TP~{tp:.4f} tf={tf}")
    except Exception as e:
        log(f"[ORDER][ERR] {symbol} {side} -> {e}")


def _gd_call_and_exec(symbol, tf, bid, ask):
    """
    Kutsuu gate_decisionia ja jos tulos on BUY/SELL (merkkijono, dict{side}, tai seq[0]),
    soittaa on_signal().
    """
    try:
        res = _gd_call_and_exec(symbol, tf, bid, ask)
    except TypeError:
        res = _gd_call_and_exec(symbol, tf)

    side = None
    if isinstance(res, str) and res.upper() in ("BUY","SELL"):
        side = res.upper()
    elif isinstance(res, dict) and str(res.get("side","")).upper() in ("BUY","SELL"):
        side = str(res["side"]).upper()
    elif isinstance(res, (tuple, list)) and res:
        cand = str(res[0]).upper()
        if cand in ("BUY","SELL"):
            side = cand

    if side:
        # bid/ask pitää olla parametrina (kutsumme wrapperia sieltä mistä hinnat on jo haettu)
        on_signal(symbol, side, tf, bid, ask)
    return res
