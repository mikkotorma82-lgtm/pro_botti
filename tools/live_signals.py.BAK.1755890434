import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"

FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: return yaml.safe_load(f)

def make_features(df: pd.DataFrame):
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(48, min_periods=12).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"]  = z["ema12"] - z["ema26"]
    d = z["close"].diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up/(down+1e-12)
    z["rsi14"] = 100 - (100/(1+rs))
    hl = z["high"]-z["low"]
    hc = (z["high"]-z["close"].shift()).abs()
    lc = (z["low"]-z["close"].shift()).abs()
    tr = pd.concat([hl,hc,lc], axis=1).max(axis=1)
    z["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean()/(z["close"]+1e-12)
    z["ema_gap"] = (z["close"]-z["ema12"])/(z["ema12"]+1e-12)
    z = z.dropna().reset_index(drop=True)
    return z

def safe_align_proba(clf, X: np.ndarray) -> dict:
    proba = clf.predict_proba(X[-1:])  # viimeinen rivi
    classes = np.array(clf.classes_)
    idx = {c:i for i,c in enumerate(classes)}
    p = { -1:1e-12, 0:1e-12, 1:1e-12 }
    for c in [-1,0,1]:
        if c in idx: p[c] = float(proba[0, idx[c]])
    s = sum(p.values())
    for k in p: p[k] = p[k]/s
    return {"-1":p[-1], "0":p[0], "1":p[1]}

def latest_signal(symbol: str, tf: str, cfg: dict) -> dict:
    p = DATA_DIR / f"{symbol}_{tf}.csv"
    df = pd.read_csv(p).sort_values("time").reset_index(drop=True); $'DROP_TIME=["time","date","datetime","timestamp","open_time","close_time"]
df.drop(columns=[c for c in DROP_TIME if c in df.columns], inplace=True, errors="ignore")
df = df.select_dtypes(include="number")'
    z = make_features(df)
    X = z[FEATS].values
    model = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    proba = safe_align_proba(model, X)
    score = proba["1"] - proba["-1"]
    signal = int(1 if score > 0.05 else (-1 if score < -0.05 else 0))
    return {
        "symbol": symbol,
        "tf": tf,
        "time": str(z["time"].iloc[-1]) if "time" in z else None,
        "price": float(z["close"].iloc[-1]),
        "signal": signal,
        "proba": proba,
        "features_used": FEATS,
    }

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="config.yaml")
    ap.add_argument("--symbols", nargs="*", required=True)
    ap.add_argument("--tf", required=True)
    args = ap.parse_args()
    cfg = load_cfg(Path(args.config))
    out = [latest_signal(s, args.tf, cfg) for s in args.symbols]
    print(json.dumps(out, indent=2))
if __name__ == "__main__":
    main()
