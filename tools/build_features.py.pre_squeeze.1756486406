import numpy as np
import pandas as pd

def _ema(s, span):
    return s.ewm(span=span, adjust=False).mean()

def _rsi(close, n=14):
    d = close.diff()
    up = d.clip(lower=0).rolling(n).mean()
    dn = (-d.clip(upper=0)).rolling(n).mean()
    rs = up / (dn.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(50)

def _atr(df: pd.DataFrame, n: int = 14) -> pd.Series:
    # Force a 1-D Series output regardless of any upstream column oddities
    h = pd.to_numeric(df["high"], errors="coerce")
    l = pd.to_numeric(df["low"], errors="coerce")
    c = pd.to_numeric(df["close"], errors="coerce")
    prev_c = c.shift(1)

    # True range as a NumPy array → wrap back to Series (guaranteed 1-D)
    tr_arr = np.maximum.reduce([
        (h - l).abs().to_numpy(),
        (h - prev_c).abs().to_numpy(),
        (l - prev_c).abs().to_numpy(),
    ])
    tr = pd.Series(tr_arr, index=df.index)
    atr = tr.rolling(n).mean()
    return atr  # Series

def build_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    Palauttaa 9-numeroista featurea, ei käytä tulevaisuuden tietoa.
    Edellyttää kolumnit: time, open, high, low, close, volume
    """
    df = df.sort_values("time").reset_index(drop=True)
    c = pd.to_numeric(df["close"],  errors="coerce")
    v = pd.to_numeric(df["volume"], errors="coerce")

    # perusmomentumit
    f = pd.DataFrame()
    f["ret1"] = c.pct_change(1)
    f["ret3"] = c.pct_change(3)
    f["ret6"] = c.pct_change(6)

    # vola/atr → force Series and numeric
    atr = _atr(df, 14)
    atr = pd.to_numeric(atr, errors="coerce")
    f["atr14n"] = (atr / c).fillna(0)

    # trendi: EMA12/26 suhteutettuna
    ema12 = _ema(c, 12); ema26 = _ema(c, 26)
    f["ema12n"] = (ema12 / c) - 1.0
    f["ema26n"] = (ema26 / c) - 1.0

    # BB-z
    sma20 = c.rolling(20).mean()
    std20 = c.rolling(20).std().replace(0, np.nan)
    f["boll_z"] = ((c - sma20) / std20).replace([np.inf, -np.inf], np.nan)

    # vol z
    vmean = v.rolling(20).mean()
    vstd  = v.rolling(20).std().replace(0, np.nan)
    f["vol_z"] = ((v - vmean) / vstd).replace([np.inf, -np.inf], np.nan)

    # rsi
    f["rsi14"] = _rsi(c, 14) / 100.0

    f = f.replace([np.inf, -np.inf], np.nan).fillna(0.0)
    return f
