from __future__ import annotations
import argparse, json, yaml
from pathlib import Path
import numpy as np, pandas as pd
from joblib import load
from core.metrics import equity_curve, max_drawdown, hitrate, profit_factor, sharpe_ratio

ROOT = Path(__file__).resolve().parents[1]
DATA_DIR = ROOT / "data" / "history"
MODEL_DIR = ROOT / "models"
OUT_DIR = ROOT / "data" / "backtests"
OUT_DIR.mkdir(parents=True, exist_ok=True)

FEATS = ["ret1","ret5","vol5","ema12","ema26","macd","rsi14","atr14","ema_gap"]

def load_cfg(p: Path) -> dict:
    with open(p,"r") as f: return yaml.safe_load(f)

def load_df(symbol, tf):
    p = DATA_DIR / f"{symbol}_{tf}.csv"
    if not p.exists(): raise FileNotFoundError(p)
    return pd.read_csv(p).sort_values("time").reset_index(drop=True); $'DROP_TIME=["time","date","datetime","timestamp","open_time","close_time"]
df.drop(columns=[c for c in DROP_TIME if c in df.columns], inplace=True, errors="ignore")
df = df.select_dtypes(include="number")'

def make_features(df: pd.DataFrame):
    z = df.copy()
    z["ret1"] = z["close"].pct_change()
    z["ret5"] = z["close"].pct_change(5)
    z["vol5"] = z["ret1"].rolling(48, min_periods=12).std()
    z["ema12"] = z["close"].ewm(span=12, adjust=False).mean()
    z["ema26"] = z["close"].ewm(span=26, adjust=False).mean()
    z["macd"]  = z["ema12"] - z["ema26"]
    d = z["close"].diff()
    up = d.clip(lower=0).ewm(alpha=1/14, adjust=False).mean()
    down = (-d.clip(upper=0)).ewm(alpha=1/14, adjust=False).mean()
    rs = up/(down+1e-12)
    z["rsi14"] = 100 - (100/(1+rs))
    hl = z["high"]-z["low"]
    hc = (z["high"]-z["close"].shift()).abs()
    lc = (z["low"]-z["close"].shift()).abs()
    tr = pd.concat([hl,hc,lc], axis=1).max(axis=1)
    z["atr14"] = tr.ewm(alpha=1/14, adjust=False).mean()/(z["close"]+1e-12)
    z["ema_gap"] = (z["close"]-z["ema12"])/(z["ema12"]+1e-12)
    z = z.dropna().reset_index(drop=True)
    return z

def equity_periods(tf: str) -> int:
    return {"15m": 2496, "1h": 624, "4h": 156}.get(tf, 252)

# ---------- Kulut (bps) konfigista ----------
def _get_costs_bps(cfg: dict, symbol: str, tf: str) -> float:
    c = (cfg.get("costs") or {})
    d = (c.get("defaults") or {})
    s = ((c.get("per_symbol") or {}).get(symbol) or {})
    t = ((c.get("per_tf") or {}).get(str(tf)) or {})
    fee = float(s.get("fee_bps", d.get("fee_bps", 0.0)))
    spread = float(s.get("spread_bps", d.get("spread_bps", 0.0)))
    slip = float(t.get("slippage_bps", s.get("slippage_bps", d.get("slippage_bps", 0.0))))
    return fee + spread + slip

# ---------- Proba turvakohdistus ----------
def safe_align_proba(clf, X: np.ndarray) -> np.ndarray:
    proba = clf.predict_proba(X)
    classes = np.array(clf.classes_)
    idx = {c:i for i,c in enumerate(classes)}
    N = proba.shape[0]
    p = np.full((N, 3), 1e-12, dtype=float)  # eps
    for j, c in enumerate([-1, 0, 1]):
        if c in idx:
            p[:, j] = proba[:, idx[c]]
    p /= p.sum(1, keepdims=True)
    return p  # columns: [-1,0,1]

def vector_sign_from_proba(p: np.ndarray, thr_long: float, thr_short: float):
    score = p[:,2] - p[:,0]
    sign = np.where(score > thr_long, 1.0, np.where(score < -thr_short, -1.0, 0.0))
    return sign, score

def apply_costs(ret_bar: np.ndarray, sign: np.ndarray, fee_bps: float) -> np.ndarray:
    fee = fee_bps/10000.0
    prev = np.concatenate([[0.0], sign[:-1]])
    entry = (prev==0.0) & (sign!=0.0)
    exit_  = (prev!=0.0) & (sign==0.0)
    flip   = (prev!=0.0) & (sign!=0.0) & (np.sign(prev)!=np.sign(sign))
    cost = np.zeros_like(ret_bar)
    cost[entry] += fee
    cost[exit_]  += fee
    cost[flip]   += 2*fee
    return ret_bar - cost

def evaluate(prices: np.ndarray, sign: np.ndarray, horizon: int, tf: str, fee_bps: float) -> dict:
    valid_n = len(prices) - horizon
    fut = prices[horizon:valid_n+horizon] / prices[:valid_n] - 1.0
    sign = sign[:valid_n].astype(float)
    ret = sign * fut
    if fee_bps != 0.0:
        ret = apply_costs(ret, sign, fee_bps)

    eq = equity_curve(ret, 1.0)
    # trade-aggregointi
    trades = []
    cur = 0.0; acc = 0.0
    for s, r in zip(sign, ret):
        if cur==0.0 and s!=0.0: cur, acc = s, r
        elif cur!=0.0 and s==cur: acc += r
        elif cur!=0.0 and s!=cur:
            trades.append(acc); cur = s; acc = 0.0 if s==0.0 else r
    if cur!=0.0: trades.append(acc)
    pnl_tr = np.asarray(trades, float)

    total_pnl = float(100.0*ret.sum())
    hr = hitrate(pnl_tr)
    dd = max_drawdown(eq)
    sharpe = sharpe_ratio(ret, equity_periods(tf))
    pf = profit_factor(pnl_tr)

    return dict(PnL=total_pnl, HitRate=hr, MaxDD=dd, Sharpe=float(sharpe),
                ProfitFactor=float(pf), trades=int(len(pnl_tr)), n_points=int(valid_n))

def backtest_one(symbol: str, tf: str, cfg: dict, thr_long: float, thr_short: float,
                 fee_bps_cli: float, optimize: bool) -> dict:
    df = load_df(symbol, tf)
    z = make_features(df)
    horizon = int((cfg.get("train",{}) or {}).get("horizon_bars",1))
    prices = z["close"].values
    X = z[FEATS].values
    valid_n = len(prices)-horizon
    if valid_n <= 50: raise RuntimeError("Too short series")

    model = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    p = safe_align_proba(model, X[:valid_n])  # Nx3

    fee_bps_cfg = _get_costs_bps(cfg, symbol, tf)
    fee_bps = fee_bps_cfg + float(fee_bps_cli)

    if optimize:
        grid = np.linspace(0.0, 0.30, 16)
        best = None
        split = int(0.6*valid_n)
        for a in grid:
            for b in grid:
                sign_is, _ = vector_sign_from_proba(p[:split], a, b)
                res_is = evaluate(prices[:split+horizon], sign_is, horizon, tf, fee_bps)
                score = res_is["Sharpe"]
                if (best is None) or (score > best[0]): best = (score, a, b)
        thr_long, thr_short = best[1], best[2]

    sign, score = vector_sign_from_proba(p, thr_long, thr_short)
    res = evaluate(prices, sign, horizon, tf, fee_bps)
    res.update(dict(symbol=symbol, tf=tf, thr_long=thr_long, thr_short=thr_short, fee_bps=fee_bps))
    outp = OUT_DIR / f"bt_{symbol}_{tf}.json"
    outp.write_text(json.dumps(res, indent=2))
    pf = res["ProfitFactor"]; pf_str = "inf" if np.isinf(pf) else f"{pf:.2f}"
    print(f"[BT] {outp}  PnL={res['PnL']:.3f}%  HR={res['HitRate']:.2f}%  DD={res['MaxDD']:.2f}%  PF={pf_str}  Sharpe={res['Sharpe']:.2f}  thr=({thr_long:.2f},{thr_short:.2f})  fee={fee_bps:.2f}bps")
    return res

# ---------- Walk-forward optimointi ----------
def walkforward(symbol: str, tf: str, cfg: dict, fee_bps_cli: float,
                is_frac: float, oos_frac: float, thr_grid=None) -> dict:
    df = load_df(symbol, tf)
    z = make_features(df)
    horizon = int((cfg.get("train",{}) or {}).get("horizon_bars",1))
    prices = z["close"].values
    X = z[FEATS].values
    valid_n = len(prices) - horizon
    if valid_n <= 200: raise RuntimeError("Too short series for WF")

    model = load(MODEL_DIR / f"pro_{symbol}_{tf}.joblib")
    p = safe_align_proba(model, X[:valid_n])
    fee_bps = _get_costs_bps(cfg, symbol, tf) + float(fee_bps_cli)

    if thr_grid is None:
        thr_vals = np.linspace(0.0, 0.30, 16)
        thr_grid = [(a,b) for a in thr_vals for b in thr_vals]

    step = max(50, int(oos_frac*valid_n))
    is_len = max(200, int(is_frac*valid_n))
    oos_returns = []
    used_thrs = []

    for start in range(0, valid_n - is_len - 1, step):
        is_lo = start
        is_hi = start + is_len
        oos_hi = min(is_hi + step, valid_n)
        p_is = p[is_lo:is_hi]
        best = None
        for (a,b) in thr_grid:
            sign_is, _ = vector_sign_from_proba(p_is, a, b)
            res_is = evaluate(prices[is_lo:is_hi+horizon], sign_is, horizon, tf, fee_bps)
            score = res_is["Sharpe"]
            if (best is None) or (score > best[0]): best = (score, a, b)
        a_best, b_best = best[1], best[2]
        used_thrs.append((a_best, b_best))

        p_oos = p[is_hi:oos_hi]
        sign_oos, _ = vector_sign_from_proba(p_oos, a_best, b_best)
        res_oos = evaluate(prices[is_hi:oos_hi+horizon], sign_oos, horizon, tf, fee_bps)
        # talteen yksittäisen ikkunan ret-sarja IS/OOS yhdistelyyn -> käytetään pelkkää metriikkaa
        oos_returns.append(res_oos)

    # Aggrekaatti OOS: punnitaan n_points:lla
    if not oos_returns:
        raise RuntimeError("WF produced no OOS windows")
    # Syntetisoidaan painotettu keskiarvo ja paras arvio kokonaissarjasta käyttämällä
    # PnL-summia ja trade-listoja ei talleteta -> käytä metriikkojen keskiarvoja painolla
    n_tot = sum(r["n_points"] for r in oos_returns)
    def wavg(key):
        return float(sum(r[key]*r["n_points"] for r in oos_returns)/n_tot)
    agg = {
        "PnL": wavg("PnL"),
        "HitRate": wavg("HitRate"),
        "MaxDD": wavg("MaxDD"),
        "Sharpe": wavg("Sharpe"),
        "ProfitFactor": wavg("ProfitFactor"),
        "oos_windows": len(oos_returns),
        "avg_thr_long": float(np.mean([a for a,_ in used_thrs])),
        "avg_thr_short": float(np.mean([b for _,b in used_thrs])),
        "fee_bps": float(fee_bps),
        "symbol": symbol, "tf": tf
    }
    outp = OUT_DIR / f"bt_{symbol}_{tf}_wf.json"
    outp.write_text(json.dumps(agg, indent=2))
    pf = agg["ProfitFactor"]; pf_str = "inf" if pf==float("inf") else f"{pf:.2f}"
    print(f"[WF] {outp}  OOS PnL={agg['PnL']:.3f}%  HR={agg['HitRate']:.2f}%  DD={agg['MaxDD']:.2f}%  PF={pf_str}  Sharpe={agg['Sharpe']:.2f}  avg_thr=({agg['avg_thr_long']:.2f},{agg['avg_thr_short']:.2f})  fee={agg['fee_bps']:.2f}bps  windows={agg['oos_windows']}")
    return agg

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--config", default="config.yaml")
    ap.add_argument("--symbols", nargs="*", default=None)
    ap.add_argument("--tfs", nargs="*", default=None)

    # Staattinen backtest
    ap.add_argument("--thr_long", type=float, default=0.05)
    ap.add_argument("--thr_short", type=float, default=0.05)
    ap.add_argument("--fee_bps", type=float, default=0.0, help="Lisätään configin kuluun (bps)")
    ap.add_argument("--optimize_thresholds", action="store_true")

    # Walk-forward
    ap.add_argument("--walkforward", action="store_true")
    ap.add_argument("--wf_is_frac", type=float, default=0.6, help="IS-osuuden koko (0-1)")
    ap.add_argument("--wf_oos_frac", type=float, default=0.2, help="OOS-askel (0-1)")

    args = ap.parse_args()

    cfg = load_cfg(Path(args.config))
    symbols = args.symbols or ((cfg.get("market",{}) or {}).get("symbols") or [])
    tfs = args.tfs or ((cfg.get("train",{}) or {}).get("timeframes") or ["15m","1h","4h"])

    for s in symbols:
        for tf in tfs:
            try:
                if args.walkforward:
                    walkforward(s, tf, cfg, args.fee_bps, args.wf_is_frac, args.wf_oos_frac)
                else:
                    backtest_one(s, tf, cfg, args.thr_long, args.thr_short, args.fee_bps, args.optimize_thresholds)
            except Exception as e:
                print(f"[FAIL BT] {s} {tf}: {e}")

if __name__ == "__main__":
    main()
